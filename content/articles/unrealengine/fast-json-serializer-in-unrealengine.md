---
title: 'UHT を拡張して UE 最速(?) 高機能な JSON シリアライザプラグインを作ってみた'
description: 'UHT を使ったコード生成プラグインで、最速(?)クラスの JSON シリアライザを作る話'
enforceCreatedAt: 2024/12/25
enforceUpdatedAt: 2024/12/25
tags:
    - Unreal Engine
    - Unreal C++
    - Blueprint
    - Advent Calendar
assets: '/article-assets/unrealengine/a-little-harder-introduction-to-blueprint'
advent_calendar:
    name: 'Unreal Engine (UE) Advent Calendar 2024'
    link: 'https://qiita.com/advent-calendar/2024/ue'
    day: 25
---

# Introduction
コンテンツやサービスの開発を行っていると、 Unreal Engine の上から Web API を呼び出したくなったり、インテグレーションツールとの連携やロギングのためにデータ構造をシリアライズしたくなることがあります。
幸いなことに、UE には C++ / BP ともに JSON を扱うための機能が提供されています。

しかし、それらの機能にはいくつかの課題点があります。そこで、今回は UHT (Unreal Header Tool) を拡張して利用することで、最速レベルのパフォーマンス持ちながら標準機能を超える機能性の JSON シリアライザプラグインである `GenJson` を開発してみました。 
エンジン改造は不要で、プラグインとして導入するだけで利用していただくことができます。

プラグインがどんなものか気になる人は [GenJsonの機能紹介](#genjson-の機能紹介) までジャンプしてみてください。

# 目次


# 標準機能の何が不満なのか？

今回作成したものの解説の前に、標準機能で JSON を操作する際の手法とその良し悪しについて整理しておきます。

## FJsonObject を使った生のオブジェクト操作
UE が提供する低レベルな Json 操作として、 C++ を使って FJsonObject のオブジェクトツリーを直接操作するものがあります。
これは以下のように使うことができます。

たしかに、この方法であれば基本的なあらゆるデータ操作を行うことができるでしょう。

### 不満なところ
- 実現したいデータ構造に対して書き込み/読み取り処理を書く必要がある
- 文字列処理から逃れられず、宣言的でない
- (要するに)とにかく愚直

ちょっとした JSON を書き出すだけであれば許容できますが、大量のエンドポイントを備えた API への対応を書きたいときや、複雑なペイロードの合成、仕様変更への追従の容易さなどを考えるとあまりうれしくないでしょう。

## UStruct のリフレクションを使った JSON 書き出し
Unreal Engine には、クラスや構造体の型や名前といった情報を、ビルド後にも残して利用できるようにするためのリフレクション機能が備わっています。
UE のスクリプト用構造体である USTRUCT(UScriptStruct) は、以下のようなコードによってフィールドの UProperty を列挙したり読み取ったりすることができます。

!TODO: サンプル

これを利用した JSON シリアライザが HHHHHHHHHHHH です。
HHHHHHHHHHH は、UScriptStruct でデータ構造を宣言しておくだけで、その UProperty を自動で読み取って適切な JSON 型でシリアライズしてくれます。

!TODO: サンプル

こちらはそこそこ良い方法といえます。外部に JSON として吐き出すためのデータ構造が構造体として定義されていて明確ですし、JSON のプロパティの名前を手動で書いたりする必要もありません。シリアライズもデシリアライズも自分で処理を書かなくてよいです。

### 不満なところ
- JSON のプロパティ名を柔軟に変更(ケース変換とか)できない。
- リフレクション情報の FName を文字列化して利用している。
- 特定の構造体のシリアライズをカスタムしたりすることができない。
- 実行時にリフレクション情報を読み出して利用しており、JSON オブジェクトを構築する前段階のコストが存在する。

こちらの不満は、主に拡張性とオーバーヘッドに関するものです。ややこしい内容が多いので項目ごとに説明していきます。


#### プロパティ名の柔軟な変更ができない
プロパティ名の変更や上書きができないのは時に致命的です。

なぜなら、UE のプロパティの命名規則は `PascalCase` なのに対し、世の中の JSON を喋るシステムは必ずしもそうとは限らず、むしろ `snake_case` や `camelCase` を採用しているシステムのが多いからです。
これに対処するには USTRUCT のプロパティ名を、Unreal C++ の命名規則を無視して `snake_case` などで書くことになりますが、気分が悪いのであまりやりたくないでしょう。

#### リフレクション情報の FName を文字列化して利用している

実行時のリフレクション情報において、プロパティ名は `FName` で持たれます。JSON シリアライズでは、これを FString に変換した結果を利用してシリアライズを行います。

問題は、`FName` は case-insensitive、すなわち格納した文字列の大文字小文字を区別しない型であること、また、同じ名前の `FName` がエンジン上で複数回作成されたとしても、先に作成されたほうの `FName` インスタンスが使い回されることです。

これが何を意味するかというと、 `FName` は以下のように、意図したのと違う文字列が `FString` として取得されるケースがあるということです。

!TODO: さんぷる

UProperty の実行時リフレクションが `FName` から取得された文字列に基づくということは、この方法を用いた JSON 生成ではフィールド名が本質的に予測不能であるということです。たまたま同名の `FName` が別の Case で先に作成されているだけで、シリアライズ結果が変わってしまいます。

#### カスタムシリアライザと併用できない
データ構造や用途によって、特定の構造体に対してだけシリアライズ処理を上書きしたいということがあります。
例えば、特定の構造体に対しては、特定のプロパティを無視したり、特定のプロパティの値を変換したり、特定のプロパティを特定の条件下でシリアライズしたりといったことが考えられます。

この方法を使ったシリアライズでは、すべてのプロパティや構造体をリフレクション情報に基づいて自動でシリアライズするため、特定の構造体に対してだけ特別な処理を行うことが難しいです。

#### リフレクションによるオーバーヘッド

また、リフレクション情報を利用して JSON オブジェクトを構築するというのは、その分のオーバーヘッドがあります。
エンジン内では、列挙したプロパティに対して以下の様なループを回すことでプロパティの型を判別し、適切な JSON オブジェクトを構築していきます。

!TODO: サンプル

リフレクションに基づくならばこうなるのは当然ですが、構造体から愚直にメンバを指定して JSON オブジェクトを構築するのと比べると、その分のオーバーヘッドが発生してしまいます。

# GenJson の機能紹介

さて、ここからは GenJson の機能を紹介していきます。 GenJson は、上記の不満を踏まえて開発したもので、以下のような特徴を持っています。

- USTRUCT にメタ指定子を与えるだけで、JSON シリアライズ機能を利用可能
- プロパティ名のケース変換や上書きが可能
- シリアライズ関数のコード生成による、リフレクション情報不要の高速シリアライズ
- カスタムシリアライズ関数の実装が容易
- UENUM にも対応
- エンジン改造なし

## USTRUCT にメタ指定子を与えるだけで JSON シリアライズ機能を利用可能
GenJson は、USTRUCT にメタ指定子を与えるだけで、その構造体を JSON シリアライズ可能にします。以下のように、`meta = (Serialize)` を USTRUCT に与えるだけで、その構造体を JSON シリアライズ可能にします。

```cpp
USTRUCT(meta = (Serialize))
struct FUserData
{
    GENERATED_BODY()

    UPROPERTY()
    FString UserName;

    UPROPERTY()
    int32 TotalScore;
};
```
次のように利用します。

```cpp
aa
```

## プロパティ名のケース変換や上書きが可能
GenJson では、プロパティ名のケース変換や上書きが可能です。以下のように、`meta = (RenameAll = "snake_case")` を UPROPERTY に与えることで、プロパティ名を `snake_case` に変換します。

```cpp
USTRUCT(meta = (Serialize, RenameAll = "snake_case"))
struct FMyStruct
{
    GENERATED_BODY()

    // ...
};
```

利用可能なケースは以下の 4 つです。

- `snake_case`
- `camelCase`
- `PascalCase`
- `kebab-case`

また、`meta = (Rename = "new_name")` を UPROPERTY に与えることで、プロパティ名を上書きすることもできます。

```cpp
USTRUCT(meta = (Serialize))
struct FMyStruct
{
    GENERATED_BODY()

    UPROPERTY(meta = (Rename = "Renamed_Property"))
    FString OriginalProperty;
};
```

サポートされていないケースにしたいときや、特定のプロパティ名を変更したいときに便利です。

## シリアライズ関数の自動生成によるハイパフォーマンスなシリアライズ
エンジンの USTRUCT 自動シリアライザは、リフレクション情報の読み出しが余計なオーバーヘッドとなっていました。
GenJson では、 `meta = (Serialize)` の指定を受けた USTRUCT に対して、以下のようなシリアライズ関数を自動生成します。

```cpp
```

リフレクション情報を利用せず、ハードコードされたプロパティ名と型を利用してシリアライズを行うため、オーバーヘッドなしで高速なシリアライズが可能です。
GenJson がシリアライズ処理を試みるとき、目的の型に対してこのようなシリアライズ関数が存在するかを探し、存在する場合はそれを利用します。
そのため、`meta = (Serialize)` を与えた USTRUCT に対しては、統一した API でシリアライズを行うことができます。

```cpp
```

さらに、シリアライズ関数の発見においては、継承や仮想関数を利用しておらず、プロパティの型に応じてコンパイル時に適切な関数を選択するため、呼び出し時にも関数呼び出し以上のオーバーヘッドは発生しません。

## カスタムシリアライズ関数の実装が容易
シリアライズ関数をカスタマイズしたい場合、 `meta = (Serialize)` でコードを生成させずに、以下の形式でシリアライズ関数を書いておけば、 GenJson はその関数を発見して利用します。

```cpp
```

書いておくだけでOKです。

## UENUM にも対応
GenJson は UENUM にも対応しています。以下のように、`meta = (Serialize)` を UENUM に与えることで、その列挙体を JSON シリアライズ可能にします。

```cpp
UENUM(meta = (Serialize))
enum class ERarity : uint8
{
    Rare, // → "Rare"
    SuperRare, // → "SuperRare"
    UltraRare // → "UltraRare"
};
```

また、UENUM のプロパティ名のケース変換や上書きも可能です。

```cpp
UENUM(meta = (Serialize, RenameAll = "snake_case"))
enum class ERarity : uint8
{
    Rare, // →　"rare"
    SuperRare, // → "super_rare"
    UltraRare // → "ultra_rare"
};
```

```cpp
UENUM(meta = (Serialize))
enum class ERarity : uint8
{
    Rare UPARAM(meta = (Rename = "Rare")), // → "Rare"
    SuperRare UPARAM(meta = (Rename = "Super_Rare")), // → "Super_Rare"
    UltraRare UPARAM(meta = (Rename = "Ultra_Rare")) // → "Ultra_Rare"
};
```

UENUM 専用の機能として、文字列ではなく数値でシリアライズすることも可能です。数値としてシリアライズしたい場合には `meta = (AsNumber)` を追加で与えます。

```cpp
UENUM(meta = (Serialize, AsNumber))
enum class ERarity : uint8
{
    Rare = 0, // → 0
    SuperRare, // → 1
    UltraRare // → 2
};
```

## エンジン改造なし
コード生成や独自の指定子などを実装していますが、エンジン改造は不要です。プラグインとして導入するだけで手軽に利用することができます。


# GenJson の仕組みと関連 UE 機能の解説
この節では、GenJson の仕組みを解説しながら、それに利用した Unreal Engine の機能についても触れていきたいと思います。 

## メタ指定子によるシリアライズ機能の制御
機能紹介でも示した通り、 GenJson では、 USTRUCT や UPROPERTY にメタ指定子を与えるだけで、実行時に利用可能なシリアライズ機能を制御することができます。
メタ指定子とはどのようなものなのかを見てみましょう。

### UHT とリフレクション
meta を説明するために、リフレクションに簡単に触れておきます。
Unreal Engine のリフレクションシステムは、以下のようなプロセスで機能しています。

!TODO: 図

UCLASS や USTRUCT, UPROPERTY といった独自マクロは、 UHT (Unreal Header Tool) がパースして解釈します。UHT は解釈した情報をもとに、プロジェクトに追加の C++ コードを生成します。ここには、各クラスやプロパティについてのリフレクション情報がコードの形で埋め込まれています。

このコードに埋め込まれた情報にアクセスすることで、実行時のリフレクションが成立しているのです。

ここで、メタ指定子もリフレクション情報に含まれるようになっています。ですから、以下のようにすることで。実行時に `meta = ()` に渡した情報にアクセスすることができるのです。

!TODO: コード

`meta = ()` の中に書けるものにルールはないので、好きな情報を Key-Value の形式でプロパティに付加することができます。

これは大変便利で、プロパティに関する周辺機能の振る舞いを、メタ指定子の情報に基づいて切り替えることができるということになります。実際、UE のエディタ内でもよく利用されており、meta の記載によってエディタ上でのプロパティの見た目が変わったりすることがあります。

### メタ指定子はパッケージングで消える
プロパティの名前、型といった基本的な情報は、UHT が埋め込んだ情報をもとにパッケージング後も利用可能です。標準の USTRUCT → JSON シリアライザも、この情報に基づいて機能しています。

しかし、 `meta = ()` で与えるメタ指定子は、その情報がパッケージングで消失してしまいます。その仕組みは単純で、 meta のリフレクション情報を格納している `MetaData` というプロパティは、エディタ向けビルド以外ではコンパイルに含まれないようになっているからです。

!TODO: WITH_EDITOR_ONLY_DATA

コードごと消えてしまうということなので、 C++ だけでは、どうやっても meta に書いた情報をパッケージング後に利用することはできません。

しかしながら、エディタが提供しているメタ指定子を眺めていると、その一部はどうもパッケージング後の挙動にも影響を与えるものがあるように見えてきます。C++ ではこれは不可能なはずですから、より上位の構造がこれを実現しているはずです。どうなっているのでしょうか？

### UHT によるコード生成
リフレクションのためのコード情報を生成しているのは UHT であると説明しました。 UHT は、C++ コンパイラよりも前に Unreal C++ のコードをパースして解釈します。

その過程で、UHT は UCLASS や UPROPERTY に記述された情報にアクセスすることができます。もちろん、そこにはメタ指定子も含まれます。つまり、メタ指定子の中の値に応じて、UHT は生成するコードを変えることができるのです。

UHT が利用しないメタデータに関してはそのまま MetaData 構造体に埋め込まれるだけで、 UHT の処理には関与しません。これではパッケージングで消えてしまい、コンテンツ機能から利用できません。 UHT を拡張して、パッケージング後にも残るような形でコード上に meta に由来する情報を残せれば、コンテンツ機能から活用することができるでしょう！

## UBT プラグインによるコード生成の拡張

GenJson の機能紹介でも述べた通り、 GenJson は UHT を拡張して、 meta の指定による JSON シリアライズ関数生成機能を提供しています。
この機能は、 UBT プラグインというメカニズムを利用しています。

UBT プラグインは、 UBT および UHT の機能を拡張するための UBT の機能です。 UBT プラグインを使うと、 UHT がパースした C++ コードや UE の独自マクロの情報を使って、新たなコードを生成したり、解析を行ったりすることができます。

UBT プラグインの作り方については、また別の記事にしたいと思いますが、ここでは GenJson が UBT プラグインを使ってどのようにして JSON シリアライズ関数を生成しているのかを見ていきたいと思います。

### GenJson によるコード生成

GenJson は、 meta = (Serialize) が指定された USTRUCT もしくは UENUM がある場合、そのファイルに対応する `.genjson.h` というファイルを生成します。
UE 標準のリフレクション機能で言うところの `.generated.h` と同じ立ち位置です。

このファイルには、そのファイルに存在する `meta = (Serialize)` が指定された USTRUCT や UENUM に対応したシリアライズ関数が記述されています。
ただ、シリアライズ関数はその場で定義されているのではなくて、「自動生成されたシリアライズ関数を埋め込むためのマクロ」が定義されます。

そのマクロが `GENJSON_SERIALIZER` です。
これを、ファイルの末尾で呼び出すことで、そのファイルに存在するシリアライズ関数が埋め込まれます。

ですから、試しに `GENJSON_SERIALIZER` マクロを展開してみると、以下のようなコードが埋め込まれていることがわかります。

```cpp
```

### SFINE による関数選択

GenJson は、シリアライズ関数の選択において、テンプレートメタプログラミングの手法である SFINAE を利用しています。
SFINAE は、関数テンプレートの特殊化を使って、コンパイル時に関数の選択を行う手法です。

GenJson のシリアライズプロセスでは、GenJson が生成したシリアライズ関数か、ユーザーが記述したシリアライズ関数かを区別していません。
どちらも SFINE によって最も一致度が高いと判断された関数が選択されます。

このため、ユーザーによるシリアライズ関数のカスタマイズが容易に行えるという特徴があります。この点は、 UE や UHT の機能を使っているわけではなく、純粋に C++ のテクニックによって実現されています。

# まだ実現できていないこと
GenJson は、アドカレネタとして 12/23 から実装を開始した超ホット(?)なプラグインです。まだまだ実装途中で、以下のような機能や検証が実現できていません。

## マルチ文字コードへの対応
現時点では、出力された JSON は常に UTF-8 でエンコードされるようになっています。 一般的な用途では問題ありませんが、 UE 内で JSON 文字列を扱う場合には、 UTF-16 に変換して FString で利用できたほうが便利です。
現状、そのためには変換を挟む必要があり好ましくありません。直接 UTF-16 で JSON 文字列を扱えるようにすることが望ましいです。

シリアライズ時に、エンコードを指定できるようにしたいです。

## デシリアライズ機能
現時点では、 GenJson はシリアライズ機能のみを提供しています。デシリアライズ機能も提供することで、 JSON 文字列から USTRUCT や UENUM に変換することができるようになります。

## メモリ使用量やパフォーマンスの検証
散々早いと言ってきましたが、実際にどの程度のパフォーマンスが出るのか、また、どの程度のメモリを消費するのか、といった実測ベースの検証がまだ行われていません。
(ちゃんとやるつもりだったのですが、アドカレの日までに間に合わなかった……)

とはいえ、GenJson はとにかく静的かつ愚直な処理のみを実行時に残すように設計されているため、標準のリフレクション機能を使ったシリアライズよりも高速であることは間違いない……はずです。

# まとめと感想
GenJson は、 UHT を拡張して UE の JSON シリアライズ機能を強化するプラグインです。
標準機能にはない、プロパティ名の柔軟な変更や上書き、高速なシリアライズ、カスタムシリアライズ関数の実装が可能です。
GenJson は、 USTRUCT や UENUM にメタ指定子を与えるだけで利用可能です。エンジン改造は不要で、プラグインとして導入するだけで利用していただくことができます。

また、UBT プラグインを使うと、 UHT を拡張してコード生成を行うことができます。 UE におけるコーディングの幅を大きく広げられます。
C# などには Roslyn といったコード解析や生成に特化したシステムがありますが、 UE では UHT を活用することで類似の機能を実現することができて便利です。

UBT プラグインの解説記事は、いつか書きますね……。

