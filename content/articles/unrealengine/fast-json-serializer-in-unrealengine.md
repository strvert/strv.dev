---
title: 'UHT を拡張して UE 最速(?) で高機能な JSON シリアライザを作ってみる'
description: 'UHT を使ったコード生成プラグインで、最速(?)クラスの JSON シリアライザを作る話'
enforceCreatedAt: 2024/12/25
enforceUpdatedAt: 2024/12/25
tags:
    - Unreal Engine
    - Unreal C++
    - Blueprint
    - Advent Calendar
assets: '/article-assets/unrealengine/a-little-harder-introduction-to-blueprint'
advent_calendar:
    name: 'Unreal Engine (UE) Advent Calendar 2024'
    link: 'https://qiita.com/advent-calendar/2024/ue'
    day: 25
---

# Introduction
コンテンツやサービスの開発を行っていると、 Unreal Engine の上から Web API を呼び出したくなったり、インテグレーションツールとの連携やロギングのためにデータ構造をシリアライズしたくなることがあります。
幸いなことに、UE には C++ / BP ともに JSON を扱うための機能が提供されています。

しかし、それらの機能にはいくつかの課題点があります。そこで、今回は UHT (Unreal Header Tool) を拡張して利用ことで、最速レベルのパフォーマンス持ちながら標準機能を超える機能性の JSON シリアライザプラグインである `GenJson` を開発してみました。 
エンジン改造は不要で、プラグインとして導入するだけで利用していただくことができます。

プラグインがどんなものか気になる人は [GenJsonの機能紹介](#GenJsonの機能紹介) までジャンプしてみてください。

# 目次


# 標準機能の何が不満なのか？

今回作成したものの解説の前に、標準機能で JSON を操作する際の手法とその良し悪しについて整理しておきます。

## FJsonObject を使った生のオブジェクト操作
UE が提供する低レベルな Json 操作として、 C++ を使って FJsonObject のオブジェクトツリーを直接操作するものがあります。
これは以下のように使うことができます。

たしかに、この方法であれば基本的なあらゆるデータ操作を行うことができるでしょう。

### 不満なところ
- 実現したいデータ構造に対して書き込み/読み取り処理を書く必要がある
- 文字列処理から逃れられず、宣言的でない
- (要するに)とにかく愚直

ちょっとした JSON を書き出すだけであれば許容できますが、大量のエンドポイントを備えた API への対応を書きたいときや、複雑なペイロードの合成、仕様変更への追従の容易さなどを考えるとあまりうれしくないでしょう。

## UStruct のリフレクションを使った JSON 書き出し
Unreal Engine には、クラスや構造体の型や名前といった情報を、ビルド後にも残して利用できるようにするためのリフレクション機能が備わっています。
UE のスクリプト用構造体である USTRUCT(UScriptStruct) は、以下のようなコードによってフィールドの UProperty を列挙したり読み取ったりすることができます。

!TODO: サンプル

これを利用した JSON シリアライザが HHHHHHHHHHHH です。
HHHHHHHHHHH は、UScriptStruct でデータ構造を宣言しておくだけで、その UProperty を自動で読み取って適切な JSON 型でシリアライズしてくれます。

!TODO: サンプル

こちらはそこそこ良い方法といえます。外部に JSON として吐き出すためのデータ構造が構造体として定義されていて明確ですし、JSON のプロパティの名前を手動で書いたりする必要もありません。シリアライズもデシリアライズも自分で処理を書かなくてよいです。

### 不満なところ
- JSON のプロパティ名を柔軟に変更(ケース変換とか)できない。
- リフレクション情報の FName を文字列化して利用している。
- 特定の構造体のシリアライズをカスタムしたりすることができない。
- 実行時にリフレクション情報を読み出して利用しており、JSON オブジェクトを構築する前段階のコストが存在する。

こちらの不満は、主に拡張性とオーバーヘッドに関するものです。ややこしい内容が多いので項目ごとに説明していきます。


#### プロパティ名の柔軟な変更ができない
プロパティ名の変更や上書きができないのは時に致命的です。

なぜなら、UE のプロパティの命名規則は `PascalCase` なのに対し、世の中の JSON を喋るシステムは必ずしもそうとは限らず、むしろ `snake_case` や `camelCase` を採用しているシステムのが多いからです。
これに対処するには USTRUCT のプロパティ名を、Unreal C++ の命名規則を無視して `snake_case` などで書くことになりますが、気分が悪いのであまりやりたくないでしょう。

#### リフレクション情報の FName を文字列化して利用している

実行時のリフレクション情報において、プロパティ名は `FName` で持たれます。JSON シリアライズでは、これを FString に変換した結果を利用してシリアライズを行います。

問題は、`FName` は case-insensitive、すなわち格納した文字列の大文字小文字を区別しない型であること、また、同じ名前の `FName` がエンジン上で複数回作成されたとしても、先に作成されたほうの `FName` インスタンスが使い回されることです。

これが何を意味するかというと、 `FName` は以下のように、意図したのと違う文字列が `FString` として取得されるケースがあるということです。

!TODO: さんぷる　

UProperty の実行時リフレクションが `FName` から取得された文字列に基づくということは、この方法を用いた JSON 生成ではフィールド名が本質的に予測不能であるということです。たまたま同名の `FName` が別の Case で先に作成されているだけで、シリアライズ結果が変わってしまいます。

#### カスタムシリアライザと併用できない

#### リフレクションによるオーバーヘッド

また、リフレクション情報を利用して JSON オブジェクトを構築するというのは、その分のオーバーヘッドがあります。
エンジン内では、列挙したプロパティに対して以下の様なループを回すことでプロパティの型を判別し、適切な JSON オブジェクトを構築していきます。

!TODO: サンプル

リフレクションに基づくならばこうなるのは当然ですが、構造体から愚直にメンバを指定して JSON オブジェクトを構築するのと比べると、その分のオーバーヘッドが発生してしまいます。

# GenJson の機能紹介

さて、ここからは GenJson の機能を紹介していきます。 GenJson は、上記の不満を踏まえて開発したもので、以下のような特徴を持っています。

- USTRUCT にメタ指定子を与えるだけで、JSON シリアライズ機能を利用可能
- プロパティ名のケース変換や上書きが可能
- コード生成によるシリアライズ関数の自動生成
- 実行時のリフレクション情報に依存せず、手書きのシリアライズ関数と遜色ないパフォーマンスを実現
- SFINE によるカスタムシリアライズ関数の実装が可能
- UHT プラグインとして実装されているため、エンジン改造は不要


# GenJson の仕組みと関連 UE 機能の解説
この節では、GenJson の仕組みを解説しながら、それに利用した Unreal Engine の機能についても触れていきたいと思います。 

## メタ指定子によるシリアライズ機能の制御
機能紹介でも示した通り、 GenJson では、 USTRUCT や UPROPERTY にメタ指定子を与えるだけで、実行時に利用可能なシリアライズ機能を制御することができます。
メタ指定子とはどのようなものなのかを見てみましょう。

### UHT とリフレクション
meta を説明するために、リフレクションに簡単に触れておきます。
Unreal Engine のリフレクションシステムは、以下のようなプロセスで機能しています。

!TODO: 図

UCLASS や USTRUCT, UPROPERTY といった独自マクロは、 UHT (Unreal Header Tool) がパースして解釈します。UHT は解釈した情報をもとに、プロジェクトに追加の C++ コードを生成します。ここには、各クラスやプロパティについてのリフレクション情報がコードの形で埋め込まれています。

このコードに埋め込まれた情報にアクセスすることで、実行時のリフレクションが成立しているのです。

ここで、メタ指定子もリフレクション情報に含まれるようになっています。ですから、以下のようにすることで。実行時に `meta = ()` に渡した情報にアクセスすることができるのです。

!TODO: コード

`meta = ()` の中に書けるものにルールはないので、好きな情報を Key-Value の形式でプロパティに付加することができます。

これは大変便利で、プロパティに関する周辺機能の振る舞いを、メタ指定子の情報に基づいて切り替えることができるということになります。実際、UE のエディタ内でもよく利用されており、meta の記載によってエディタ上でのプロパティの見た目が変わったりすることがあります。

### メタ指定子はパッケージングで消える
プロパティの名前、型といった基本的な情報は、UHT が埋め込んだ情報をもとにパッケージング後も利用可能です。標準の USTRUCT → JSON シリアライザも、この情報に基づいて機能しています。

しかし、 `meta = ()` で与えるメタ指定子は、その情報がパッケージングで消失してしまいます。その仕組みは単純で、 meta のリフレクション情報を格納している `MetaData` というプロパティは、エディタ向けビルド以外ではコンパイルに含まれないようになっているからです。

!TODO: WITH_EDITOR_ONLY_DATA

コードごと消えてしまうということなので、 C++ だけでは、どうやっても meta に書いた情報をパッケージング後に利用することはできません。

しかしながら、エディタが提供しているメタ指定子を眺めていると、その一部はどうもパッケージング後の挙動にも影響を与えるものがあるように見えてきます。C++ ではこれは不可能なはずですから、より上位の構造がこれを実現しているはずです。どうなっているのでしょうか？

### UHT によるコード生成
リフレクションのためのコード情報を生成しているのは UHT であると説明しました。 UHT は、C++ コンパイラよりも前に Unreal C++ のコードをパースして解釈します。

その過程で、UHT は UCLASS や UPROPERTY に記述された情報にアクセスすることができます。もちろん、そこにはメタ指定子も含まれます。つまり、メタ指定子の中の値に応じて、UHT は生成するコードを変えることができるのです。

UHT が利用しないメタデータに関してはそのまま MetaData 構造体に埋め込まれるだけで、 UHT の処理には関与しません。これではパッケージングで消えてしまい、コンテンツ機能から利用できません。 UHT を拡張して、パッケージング後にも残るような形でコード上に meta に由来する情報を残せれば、コンテンツ機能から活用することができるでしょう！

GenJson では、このために UBT プラグインという機能を利用しています。

## UBT プラグインによるコード生成の拡張

GenJson では、メタ指定子に Serialize が指定された USTRUCT を発見すると、以下のようなその専用のシリアライズ関数を自動生成します。

!TODO: コード

コードを見ると分かる通り、コード中にすでにシリアライズ時に利用される名前や JSON プロパティの型がハードコードされています。このコードをを実行するときには、 UE の既存のリフレクションシステムには依存せず、極めてシンプルな JSON オブジェクトの書き込み操作のみが行われます。

RenameAll や Rename などの指定子を加えるとどうなるでしょうか？

!TODO: コード

UHT が生成する関数で利用される名前が変わりました。これにより、ケース変換や特定のプロパティの名前の上書きが実現されます。