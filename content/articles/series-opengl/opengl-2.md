---
title: OpenGL入門から3DCGレンダラ実装まで その2
description: "OpenGL入門から3DCGレンダラ実装まで"
series: "OpenGL入門から3DCGレンダラ実装まで"
seriesIndex: 2
tags:
  - 'OpenGL'
---

# そもそもOpenGLとは?
## 概要
OpenGLとは、Khronos Groupという団体が策定している2D/3D グラフィックスライブラリの**オープン標準規格**です。
つまり、Khronos GroupはOpenGLという**ライブラリそのもの**の実装は行なっておらず、どのような命令でどのような効果が得られるのかというAPIの策定と公開を行なっているということになります。

通常、私達が利用することになるライブラリとしてのOpenGLは、GPUの各開発企業が自社のGPU向けに実装を行なったものとなります[^1]。
OpenGLはオープン標準でありどの企業も自社のGPUで利用できるようにすることができます。しかし、世に存在するOpenGLを使いたいGPU全てで動く実装を1つの団体が公開するのは事実上不可能であるため、このような形になっていると思われます。

OpenGL自体は、GPUなどのハードウェアやそれを制御するデバイスドライバに近い低レベルなAPIです[^2]。

## アーキテクチャ
### コンテキスト
OpenGLは、それ自体が巨大なステートマシンとなっています。内部的にOpenGLのステートを示す変数を持つ巨大なデータ構造を保持しており、このデータ構造のことをOpenGLではコンテキストと言います。OpenGLを用いたプログラミングでは、用意されたAPIを用いてOpenGLに命令を発行し、コンテキストを更新することで描画を制御することになります。
コンテキストは同時に複数発行することが可能で、例えば同時にOpenGLを用いたウィンドウを複数起動する場合、ウィンドウごとに更新対象とするコンテキストをスイッチングすることでOpenGLを用いたGPUレンダリングを同時に行うことができます。

言葉ではあまりしっくりこないかもしれませんが、この点は実際にOpenGLでプログラムを記述するとよくわかります[^3]。

### プロファイルとレンダリングパイプライン
OpenGLにおける**プロファイル**とは、簡単に言うとコンテキストが保持する状態の種類やそれに対する制御を行うインターフェースの種類などによって区別されるAPIセットのことです。
2019年現在のOpenGLには、**コアプロファイル(Core contexts)**と**互換プロファイル**の2つのプロファイルが存在します。これらのプロファイルはそれぞれ別の仕様として独立してOpenGLの各バージョンごとに策定されています。以下の画像はKhronos Groupページで公開されている仕様一覧の様子です。
![DeepinScreenshot_select-area_20191215065917.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/225893/2d404c14-f0dc-3d43-52a0-052ffc5002ba.png)

同一のバージョンに対して複数のAPIが用意されているのは一見不思議ですが、これにはOpenGLの歴史的経緯が関係しています。OpenGLはバージョン3.0以上と未満で大きく思想が異なっており、そこにAPI的な互換性はありません。つまり、OpenGL 2.xのころのコードをOpenGL 3.xや4.x環境で普通に動かそうとしても、APIが変化しているためビルドできないということです。[^4]
そして、各バージョンが提供しているメインの最新API仕様、これがコア仕様であり、**コアプロファイル**であるということになります。

しかし、高バージョンのOpenGLが提供する機能を、OpenGL 2.x以前のAPI仕様に則ったコードから利用したい、3.x以上への対応のためにコードを書き換えたくないという需要も存在します。そのようなケースのために今現在も用意されているのが各バージョンの**互換プロファイル**であるということのようです。

コアプロファイルと互換プロファイルの主な違いとして、主要な**レンダリングパイプライン**の違いがあります。

**レンダリングパイプライン**とは頂点データやテクスチャデータなどの元データから、実際に画面に描画する2次元の画像データを生成するまでの過程のことです。

**コアプロファイル**で採用されているレンダリングパイプラインは**GLSL(OpenGL Shading Language)**と呼ばれるGPU上で実行される専用のプログラミング言語(シェーダー言語)を用いたもので、このようなプログラマによって設計・記述が可能なシェーダー言語を用いたレンダリングパイプラインは「**プログラマブルシェーダ**を用いたレンダリングパイプライン」であると言われます。

一方、**互換プロファイル**で利用できるレンダリングパイプラインは**固定機能パイプライン(Fixed function pipeline)**であると言われます。
それぞれのパイプラインの特徴を以下に示します。

#### **固定機能パイプライン**
  - 単純な命令ですぐに描画を行うことができる。OpenGLにおけるHello World的なところに到達するまでのコストは低く、はじめやすい。
  - 多くの部分がプログラマブルシェーダーを用いる場合と比較して抽象化されOpenGL内部に隠されている。プログラマが細かい制御をいじることが出来ない。
  - OpenGLが実際に内部で何をやっているのかわかりにくく、パフォーマンスチューニング可能な範囲や柔軟性などに限界がある。

#### **プログラマブルシェーダー**
  - Hello Worldまでの学習コストが固定機能パイプラインと比較して高い。少し描画を行うだけでもGLSLと呼ばれるシェーダー言語を記述する必要がある。
  - 抽象度が固定機能パイプラインと比較して低く、細かい命令をプログラマがOpenGLに与えなければならない。
  - シェーダーを用いると固定機能パイプラインでは殆ど固定されていたGPU内部でのレンダリングパイプラインの処理をプログラマが設計し記述することができる。[^5]
  - 非常に柔軟性が高く表現の幅が広い。また、適切に記述すれば効率的な処理を作ることができる。

プログラマブルシェーダーを用いたコアプロファイルのレンダリングパイプラインは学習コストが若干高いですが、現在推奨される方法であり、実際にGPUを用いたレンダリングで何をやっているのかの概要を理解するにもうってつけのものになっているため、今回の記事シリーズではコアプロファイルを採用してやっていきます。[^6]
