__NUXT_JSONP__("/blog/unrealengine--lets-implement-a-single-mesh-renderer-2", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ,aR,aS,aT,aU,aV,aW,aX,aY,aZ,a_,a$,ba,bb,bc,bd,be,bf,bg,bh,bi,bj,bk,bl,bm,bn,bo,bp,bq,br,bs,bt,bu,bv,bw,bx,by,bz,bA,bB,bC,bD,bE,bF,bG,bH,bI,bJ,bK,bL,bM,bN,bO,bP,bQ,bR,bS,bT,bU,bV,bW,bX,bY,bZ,b_,b$,ca,cb,cc,cd,ce,cf,cg,ch,ci,cj,ck,cl,cm,cn,co,cp,cq,cr,cs,ct){return {data:[{page:{slug:"lets-implement-a-single-mesh-renderer-2",description:"アイテムの描画とか、一つだけのメッシュをレンダリングするのに便利なツールを実装してみる記事のその２。独自のメッシュパスを実装して単一パスの軽量なレンダラを書くのに必要なUnreal Engine の描画機能について解説する",title:"単一Static Meshレンダラを独自メッシュパスで実装する...ための前提知識編",enforceCreatedAt:aS,enforceUpdatedAt:aS,tags:["Unreal Engine","Unreal C++","RHI","RDG","Advent Calendar"],assets:"\u002Farticle-assets\u002Funrealengine\u002Flets-implement-a-single-mesh-renderer-2",advent_calendar:{name:"Unreal Engine (UE) Advent Calendar 2023",link:"https:\u002F\u002Fqiita.com\u002Fadvent-calendar\u002F2023\u002Fue",day:17},toc:[{id:aT,depth:F,text:U},{id:aU,depth:F,text:V},{id:aV,depth:F,text:ae},{id:aW,depth:F,text:ao},{id:aX,depth:F,text:ap},{id:_,depth:aY,text:_},{id:aZ,depth:aY,text:aq},{id:$,depth:F,text:$},{id:a_,depth:F,text:ar},{id:a$,depth:F,text:af},{id:ba,depth:F,text:as},{id:bb,depth:F,text:at},{id:bc,depth:F,text:au},{id:bd,depth:F,text:av},{id:be,depth:F,text:aw},{id:bf,depth:F,text:ax}],body:{type:"root",children:[{type:b,tag:O,props:{id:"introduction"},children:[{type:b,tag:l,props:{href:"#introduction",ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:"Introduction"}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"この記事は、昨日投稿した記事、『"},{type:b,tag:l,props:{href:"https:\u002F\u002Fstrv.dev\u002Fblog\u002Funrealengine--lets-implement-a-single-mesh-renderer",rel:["nofollow","noopener","noreferrer"],target:"_blank"},children:[{type:a,value:"単一 Static Meshレンダラを実装する (FPreviewScene編)"}]},{type:a,value:"』の続編です。\n昨日の記事では、FPreviewScene という機能を利用し、裏に別の World \u002F Scene を用意して、そちらでメッシュをレンダリングする実験をしました。"}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"前回の手法には課題も多かったので、より単独メッシュのレンダリングに特化した独自のメッシュパスを追加することで、高速にメッシュ画像を得る記事を書こうと思いました。\nしかし、その実装を説明するための前提知識が多いので、まずは前提知識編を書きます。UE がメッシュをレンダリングする機構についてまとめるので、よければ参考にしてください。"}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"(これは UE アドカレ 2023 に12\u002F25に投稿した記事です！　空いてた過去枠にタイムリープ投稿しています)"}]},{type:a,value:f},{type:b,tag:O,props:{id:bg},children:[{type:b,tag:l,props:{href:"#%E7%9B%AE%E6%AC%A1",ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:bg}]},{type:a,value:f},{type:b,tag:Q,props:{},children:[{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:l,props:{href:bh},children:[{type:a,value:bi}]}]},{type:a,value:f},{type:b,tag:Q,props:{},children:[{type:a,value:f},{type:b,tag:r,props:{},children:[{type:b,tag:l,props:{href:bj},children:[{type:a,value:U}]}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:b,tag:l,props:{href:bk},children:[{type:a,value:V}]}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:b,tag:l,props:{href:bl},children:[{type:a,value:ae}]}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:l,props:{href:bm},children:[{type:a,value:ay}]}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:l,props:{href:bn},children:[{type:a,value:az}]}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:l,props:{href:bo},children:[{type:a,value:aA}]}]},{type:a,value:f},{type:b,tag:Q,props:{},children:[{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:l,props:{href:bp},children:[{type:a,value:ao}]}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:l,props:{href:bq},children:[{type:a,value:ap}]}]},{type:a,value:f},{type:b,tag:Q,props:{},children:[{type:a,value:f},{type:b,tag:r,props:{},children:[{type:b,tag:l,props:{href:br},children:[{type:a,value:_}]}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:b,tag:l,props:{href:bs},children:[{type:a,value:aq}]}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:l,props:{href:bt},children:[{type:a,value:$}]}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:l,props:{href:bu},children:[{type:a,value:ar}]}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:l,props:{href:bv},children:[{type:a,value:aB}]}]},{type:a,value:f},{type:b,tag:Q,props:{},children:[{type:a,value:f},{type:b,tag:r,props:{},children:[{type:b,tag:l,props:{href:bw},children:[{type:a,value:af}]}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:b,tag:l,props:{href:bx},children:[{type:a,value:as}]}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:b,tag:l,props:{href:by},children:[{type:a,value:at}]}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:l,props:{href:bz},children:[{type:a,value:bA}]}]},{type:a,value:f},{type:b,tag:Q,props:{},children:[{type:a,value:f},{type:b,tag:r,props:{},children:[{type:b,tag:l,props:{href:bB},children:[{type:a,value:au}]}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:b,tag:l,props:{href:bC},children:[{type:a,value:av}]}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:b,tag:l,props:{href:bD},children:[{type:a,value:aw}]}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:b,tag:l,props:{href:bE},children:[{type:a,value:ax}]}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:l,props:{href:bF},children:[{type:a,value:aC}]}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:l,props:{href:bG},children:[{type:a,value:aD}]}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:O,props:{id:"shader-はどうやって扱われるのか"},children:[{type:b,tag:l,props:{href:bh,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:bi}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"UE には、Shader のコードや、それが利用するパラメータのリフレクション情報などをまとめた "},{type:b,tag:n,props:{},children:[{type:a,value:ag}]},{type:a,value:" というクラスがあります。\nこのクラスの派生として、 "},{type:b,tag:n,props:{},children:[{type:a,value:U}]},{type:a,value:" や "},{type:b,tag:n,props:{},children:[{type:a,value:V}]},{type:a,value:" などがあります。"}]},{type:a,value:f},{type:b,tag:G,props:{id:aT},children:[{type:b,tag:l,props:{href:bj,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:U}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"UE でシェーダーを書くとき、最も利用するクラスだと思います。HLSL + C++ で完結する機能である場合にはとりあえずこれを使っておけば、VS, PS, CS はもちろん、GSなどのシェーダーも定義することができます。\n定義のためには RDG のマクロを活用すると楽に扱うことが可能で、次のサンプルのようにパラメータやエントリポイントを設定することができます。"}]},{type:a,value:f},{type:b,tag:B,props:{className:[P]},children:[{type:b,tag:H,props:{className:[y]},children:[{type:b,tag:n,props:{className:[y]},children:[{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:"class"}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,C]},children:[{type:a,value:ah}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:":"}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,"base-clause"]},children:[{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:"public"}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,C]},children:[{type:a,value:U}]}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:W}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"DECLARE_GLOBAL_SHADER"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ah},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"SHADER_USE_PARAMETER_STRUCT"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ah},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:" FGlobalShader"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:bH},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"BEGIN_SHADER_PARAMETER_STRUCT"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:aE},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:R},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"SHADER_PARAMETER_STRUCT_REF"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"FViewUniformShaderParameters"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:aF},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:R},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"SHADER_PARAMETER_STRUCT"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"FScreenPassTextureViewportParameters"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:bI},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:R},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"SHADER_PARAMETER_STRUCT_INCLUDE"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"FSceneTextureShaderParameters"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:" SceneTextures"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:R},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"SHADER_PARAMETER_SAMPLER"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"SamplerState"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,o,"type-opencl-host-cpp"]},children:[{type:a,value:"Sampler"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:R},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"RENDER_TARGET_BINDING_SLOTS"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"END_SHADER_PARAMETER_STRUCT"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:Y},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"IMPLEMENT_GLOBAL_SHADER"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ah},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,S]},children:[{type:a,value:"\"\u002FStaticMeshRendererShaders\u002FPrivate\u002FBufferVisualizeShader.usf\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:"\n                        "},{type:b,tag:c,props:{className:[d,S]},children:[{type:a,value:"\"MainPS\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:" SF_Pixel"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:Y}]}]}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"BEGIN_SHADER_PARAMTER_STRUCT() などのマクロを使うと、その場にパラメータの構造体が宣言されます。単に構造体ができるだけではなく、変数名のリフレクションやメモリレイアウトの最適化なども行ってくれます。\nここで収集された名前はシェーダー内で値にアクセスするときのパラメータ名にもなるので、従来手動で行っていたバインド処理などを行わなくてよくなっています。"}]},{type:a,value:f},{type:b,tag:G,props:{id:aU},children:[{type:b,tag:l,props:{href:bk,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:V}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"これも "},{type:b,tag:n,props:{},children:[{type:a,value:ag}]},{type:a,value:" の派生です。様々なシェーダータイプに対応している点は "},{type:b,tag:n,props:{},children:[{type:a,value:U}]},{type:a,value:" と同様ですが、こちらは Material で記述されたノードグラフと組み合わせて使うためのベースクラスです。\nUE の Material は、ノードベースでシェーダーを書けるようにした機能です。背後では、Material が生成した HLSL コードを、 "},{type:b,tag:n,props:{},children:[{type:a,value:V}]},{type:a,value:" で実装されたシェーダーが利用する形でレンダリングに使用されています。\n"},{type:b,tag:n,props:{},children:[{type:a,value:V}]},{type:a,value:" には、その組み合わせ部分をサポートするためのユーティリティが実装されています。"}]},{type:a,value:f},{type:b,tag:G,props:{id:aV},children:[{type:b,tag:l,props:{href:bl,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:ae}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:V}]},{type:a,value:" を更に派生したクラスで、マテリアルを使いつつメッシュを描画することを目的とした機能が実装されています。\nUE には、レンダリング処理にメッシュ情報を渡すための処理を行う "},{type:b,tag:n,props:{},children:[{type:a,value:bJ}]},{type:a,value:" というクラスがあります。 "},{type:b,tag:n,props:{},children:[{type:a,value:ae}]},{type:a,value:" は、 "},{type:b,tag:n,props:{},children:[{type:a,value:bJ}]},{type:a,value:" が提供する頂点バッファ情報やレイアウト情報をシェーダーのパラメータとしてバインディングすることができます。"}]},{type:a,value:f},{type:b,tag:O,props:{id:ay},children:[{type:b,tag:l,props:{href:bm,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:ay}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:ag}]},{type:a,value:" の派生を実装するとき、そのシェーダーのコンパイル設定を行いたいことがあります。たとえば、.ush \u002F .ush 内のマクロの定義を変更したいとか、 コンパイル結果の検証を追加したいとかです。\nそのような場合には、 "},{type:b,tag:n,props:{},children:[{type:a,value:ag}]},{type:a,value:" の以下の static メンバ関数をオーバーライドすることができます。"}]},{type:a,value:f},{type:b,tag:B,props:{className:[ai]},children:[{type:b,tag:B,props:{className:[aj]},children:[{type:a,value:"Shader.h"}]},{type:b,tag:H,props:{},children:[{type:b,tag:n,props:{className:[y]},children:[{type:a,value:"\u002F** サブクラスでオーバーライドして、コンパイルが行われる直前にコンパイル環境を変更することができる。 *\u002F\nstatic void ModifyCompilationEnvironment(const FShaderPermutationParameters&, FShaderCompilerEnvironment&) {}\n\n\u002F** サブクラスでオーバーライドして、特定の並べ替えがコンパイルされるべきかどうかを決定することができる。 *\u002F\nstatic bool ShouldCompilePermutation(const FShaderPermutationParameters&) { return true; }\n\n\u002F** コンパイル結果が有効かどうかを判断するために、サブクラスでオーバーライドすることができる。 *\u002F\nstatic bool ValidateCompiledResult(EShaderPlatform InPlatform, const FShaderParameterMap& InParameterMap, TArray\u003CFString\u003E& OutError) { return true; }"}]}]}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"たとえば、 FGlobalShader を継承している場合に "},{type:b,tag:n,props:{},children:[{type:a,value:aG}]},{type:a,value:" をオーバーライドするとしたら、次のようになります。"}]},{type:a,value:f},{type:b,tag:B,props:{className:[P]},children:[{type:b,tag:H,props:{className:[y]},children:[{type:b,tag:n,props:{className:[y]},children:[{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aH}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aa}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:aG}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:" FGlobalShaderPermutationParameters"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:aI},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:" FShaderCompilerEnvironment"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:bK},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:W}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F 親の実装も呼んであげる(任意)"}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,C]},children:[{type:a,value:U}]},{type:b,tag:c,props:{className:[d,e,K]},children:[{type:a,value:L}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:aG}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:bL},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:bK},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:bH},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F Define を追加"}]},{type:a,value:"\n\tOutEnvironment"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"SetDefine"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,S]},children:[{type:a,value:"\"SUPPORTS_ANISOTROPIC_MATERIALS\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,"number"]},children:[{type:a,value:"0"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:X}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"また、"},{type:b,tag:n,props:{},children:[{type:a,value:bM}]},{type:a,value:" はかなり重要です。この関数の挙動によって、生成されるシェーダーの数に大きな影響が出る可能性があります。\nそもそも、Shader Permutation とは、シェーダー実装が適用対象、機能、プラットフォーム、ライトなど様々な使用方法で動作できるように、用途の組み合わせごとに微妙に異なるシェーダーを生成する仕組みのことです。\nUE のシェーダーには多数のマクロが利用されており、利用方法に合わせてマクロの値がスイッチするようになっています。これを知らずに運用すると、組み合わせ爆発によって膨大な数のシェーダーをコンパイルしてパッケージに含めることになってしまうこともあります。"}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:bM}]},{type:a,value:" には、そのシェーダーのコンパイルが特定の条件下で必要かどうかを判定する実装を追加できます。以下は FMeshMaterialShader を継承しているときの実装例です。"}]},{type:a,value:f},{type:b,tag:B,props:{className:[P]},children:[{type:b,tag:H,props:{className:[y]},children:[{type:b,tag:n,props:{className:[y]},children:[{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aH}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:"bool"}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"ShouldCompilePermutation"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:" FMeshMaterialShaderPermutationParameters"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:aI},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:W}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aH}]},{type:a,value:" FName "},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:bN}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,S]},children:[{type:a,value:"\"FLocalVertexFactory\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:bO}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:bL},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:a,value:"MaterialParameters"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:a,value:"MaterialDomain "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:bP}]},{type:a,value:" MD_Surface"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:ak}]},{type:a,value:"\n\t\tParameters"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:a,value:"VertexFactoryType "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:bP}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"FindVertexFactoryType"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:bN},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:X}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"この例では、利用している Vertex Factory(後述) が "},{type:b,tag:n,props:{},children:[{type:a,value:"FLocalVertexFactory"}]},{type:a,value:" で、利用しようとしているマテリアルにドメインが "},{type:b,tag:n,props:{},children:[{type:a,value:"Surface"}]},{type:a,value:" であるときにだけコンパイルされるべきであるとしています。\nこれを設定しないと、本来利用しない or 利用できない使用方法に対しても無駄にシェーダー生成の組み合わせを増やしてしまうおそれがあります。"}]},{type:a,value:f},{type:b,tag:O,props:{id:az},children:[{type:b,tag:l,props:{href:bn,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:az}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"VertexFactory は、Vertex Shader が必要とする頂点データのリソースを提供してくれるもので、C++ \u002F HLSL の両方で提供されます。\nVertex Shader で行う処理はメッシュタイプによって違うので、 VertexFactory もメッシュにあわせて種類があります。\nたとえば、"}]},{type:a,value:f},{type:b,tag:Q,props:{},children:[{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:"StaticMesh\n"},{type:b,tag:Q,props:{},children:[{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:"FLocalVertexShader"}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:"SkeletalMesh\n"},{type:b,tag:Q,props:{},children:[{type:a,value:f},{type:b,tag:r,props:{},children:[{type:a,value:"FGpuSkinVertexFactory"}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"などです。これらは C++ クラスですが、次のようにして .ush と実装と関連付けることで、VertexShader への入力を定義します。"}]},{type:a,value:f},{type:b,tag:B,props:{className:[ai]},children:[{type:b,tag:B,props:{className:[aj]},children:[{type:a,value:"LocalVertexFactoryの例"}]},{type:b,tag:H,props:{},children:[{type:b,tag:n,props:{className:[y]},children:[{type:a,value:"\u002F\u002F C++ 側実装\nclass FLocalVertexFactory : public FVertexFactory\n{\n\tDECLARE_VERTEX_FACTORY_TYPE_API(FLocalVertexFactory, ENGINE_API);\n\t\u002F\u002F 略\n};\n\n\u002F\u002F .ush の関連付けを定義\nIMPLEMENT_VERTEX_FACTORY_TYPE(FLocalVertexFactory,\"\u002FEngine\u002FPrivate\u002FLocalVertexFactory.ush\",\n\t  EVertexFactoryFlags::UsedWithMaterials\n\t| EVertexFactoryFlags::SupportsStaticLighting\n\t| EVertexFactoryFlags::SupportsDynamicLighting\n\t| EVertexFactoryFlags::SupportsPrecisePrevWorldPos\n\t| EVertexFactoryFlags::SupportsPositionOnly\n\t| EVertexFactoryFlags::SupportsCachingMeshDrawCommands\n\t| EVertexFactoryFlags::SupportsPrimitiveIdStream\n\t| EVertexFactoryFlags::SupportsRayTracing\n\t| EVertexFactoryFlags::SupportsRayTracingDynamicGeometry\n\t| EVertexFactoryFlags::SupportsLightmapBaking\n\t| EVertexFactoryFlags::SupportsManualVertexFetch\n\t| EVertexFactoryFlags::SupportsPSOPrecaching\n\t| EVertexFactoryFlags::SupportsGPUSkinPassThrough\n\t| EVertexFactoryFlags::SupportsLumenMeshCards\n);"}]}]}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"すると、VertexShader で処理中のメッシュタイプに合わせた Vertex Factory の値を "},{type:b,tag:n,props:{},children:[{type:a,value:bQ}]},{type:a,value:" パラメータとして利用できるようになります。"}]},{type:a,value:f},{type:b,tag:B,props:{className:[ai]},children:[{type:b,tag:B,props:{className:[aj]},children:[{type:a,value:"VSでの入力例"}]},{type:b,tag:H,props:{},children:[{type:b,tag:n,props:{className:["language-hlsl"]},children:[{type:a,value:"\u002F\u002F この include で、自動的に VS が適用されているメッシュの VertexFactory が選択的に include される。\n#include \"\u002FEngine\u002FGenerated\u002FVertexFactory.ush\"\n\n\u002F\u002F FVertexFactoryInput の中身が利用している VertexFactory の定義になる\nvoid MainVS(FVertexFactoryInput Input, out float4 Position: SV_POSITION)\n{\n\t\u002F\u002F 略\n}"}]}]}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"VertexFactory のシェーダを書くときにはいくつかの「お約束」があり、ファクトリが提供すべき型の名前("},{type:b,tag:n,props:{},children:[{type:a,value:bQ}]},{type:a,value:"や"},{type:b,tag:n,props:{},children:[{type:a,value:"FVertexFactoryIntermediates"}]},{type:a,value:")や、関数の名前があります。\n名前が揃えられていることで、シェーダーに include させる VertexFactory シェーダーの切り替えで頂点データの取得処理を変化させることができるのです。そして、切り替えはUEのシェーダーシステムが自動的に行なってくれます。\nこれにより、様々なメッシュタイプごとに VertexShader を書かなくても、VertexFactory によって抽象化されたあとの頂点データへの処理だけを考えればよくなっているのです。"}]},{type:a,value:f},{type:b,tag:O,props:{id:aA},children:[{type:b,tag:l,props:{href:bo,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:aA}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"シェーダーの定義方法を説明しましたが、それを使った命令の発行と実行を知らなければ描画を実行できません。\n現在 (UE5.3) のバージョンでは、 RDG (Rendering Dependency Graph) という機能があり、これを使うと便利に描画リソース管理や描画命令発行ができます。"}]},{type:a,value:f},{type:b,tag:G,props:{id:aW},children:[{type:b,tag:l,props:{href:bp,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:ao}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"RDG を使った描画機能の実装は、以下のボイラープレートから開始することができます。"}]},{type:a,value:f},{type:b,tag:B,props:{className:[P]},children:[{type:b,tag:H,props:{className:[y]},children:[{type:b,tag:n,props:{className:[y]},children:[{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aa}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,C]},children:[{type:a,value:"UTinyRenderer"}]},{type:b,tag:c,props:{className:[d,e,K]},children:[{type:a,value:L}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"Render"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:W}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F Render() が GameThread で呼ばれる"}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F -------"}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F ENQUEUE_RENDER_COMMAND マクロはラムダ式を RenderThread の実行キューに追加する"}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"ENQUEUE_RENDER_COMMAND"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"FStaticMeshRenderCommand"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:R},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bR}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bS}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"FRHICommandListImmediate"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:bT},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:"mutable"}]},{type:a,value:R},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:W}]},{type:a,value:aJ},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F RenderThread で実行される。RHICmdList から GraphBuilder を作成する。"}]},{type:a,value:"\n\t\t\tFRDGBuilder "},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:bU}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"RHICmdList"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:"\n\t\t\t                         "},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:bV}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,S]},children:[{type:a,value:"\"StaticMeshRender\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:"\n\t\t\t                         ERDGBuilderFlags"},{type:b,tag:c,props:{className:[d,e,K]},children:[{type:a,value:L}]},{type:a,value:"AllowParallelExecute"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:bW},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F ここでGraphBuilder を使って描画命令の発行(パスの追加とか)を行う"}]},{type:a,value:bW},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F ↓ でBuilderが命令の発行を行う "}]},{type:a,value:"\n\t\t\tGraphBuilder"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"Execute"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:R},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:X}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"レンダースレッド実行時に渡されてくる RHICmdList とは、RHI (Rendering Hardware Interface) のコマンドバッファです。RHI はグラフィックス機能の抽象化レイヤで、ハードウェアやプラットフォームの差異をUEが吸収してくれているものです。"}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"RHI コマンドを RHICmdList に追加することで、描画処理を構築することができるのですが、RDG を使う場合は直接触れる機会が少し減ります。それは、RHI コマンドの構築は RDGBuilder が内部で行ってくれるからです。 RDGBuilder が提供する API を使って描画処理を記述すると、内部で処理のマージや並び替え、リソース管理命令の自動追加などを行った上で(DAGで実装されている)、適切なコマンドリストを生成してくれるのです。"}]},{type:a,value:f},{type:b,tag:G,props:{id:aX},children:[{type:b,tag:l,props:{href:bq,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:ap}]},{type:a,value:f},{type:b,tag:bX,props:{id:_},children:[{type:b,tag:l,props:{href:br,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:_}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"例として、いくつかのリソースを RDG で作成してみます。"}]},{type:a,value:f},{type:b,tag:B,props:{className:[P]},children:[{type:b,tag:H,props:{className:[y]},children:[{type:b,tag:n,props:{className:[y]},children:[{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F テクスチャの作成"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:" FRDGTextureDesc Desc "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:E}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,C]},children:[{type:a,value:"FRDGTextureDesc"}]},{type:b,tag:c,props:{className:[d,e,K]},children:[{type:a,value:L}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"Create2D"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"RectSizeXY"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:" PF_DepthStencil"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tFClearValueBinding"},{type:b,tag:c,props:{className:[d,e,K]},children:[{type:a,value:L}]},{type:a,value:"DepthFar"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:" TexCreate_DepthStencilTargetable "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:bY}]},{type:a,value:" TexCreate_ShaderResource"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:" FRDGTextureRef SceneDepth "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:E}]},{type:a,value:T},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"CreateTexture"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"Desc"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,S]},children:[{type:a,value:"\"SceneDepthZ\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F バッファリソースとSRVの作成"}]},{type:a,value:"\nTArray"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:I}]},{type:a,value:"FVector4f"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:J}]},{type:a,value:" InstanceSceneDataSOA "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:E}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F* データを書き込み *\u002F"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:" FRDGBufferRef RDGInstanceSceneDataBuffer "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:E}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"CreateStructuredBuffer"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:bU},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:R},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,S]},children:[{type:a,value:"\"InstanceSceneDataBuffer\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:" InstanceSceneDataSOA"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:"\nGPUScene"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:a,value:"GPUSceneInstanceSceneData "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:E}]},{type:a,value:T},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"CreateSRV"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"RDGInstanceSceneDataBuffer"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F RDG マクロで定義したシェーダパラメータの作成"}]},{type:a,value:"\nFTinyRendererShaderParameters"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:M}]},{type:a,value:bZ},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:E}]},{type:a,value:T},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,al]},children:[{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:b_}]},{type:b,tag:c,props:{className:[d,C,am]},children:[{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:I}]},{type:a,value:aK},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:J}]}]}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"注意しなければいけないのは、"},{type:b,tag:b$,props:{},children:[{type:a,value:"RDG が管理するリソースが本当に確保されることが保証されるのは後述する RDG Pass の間だけである"}]},{type:a,value:"ということです。上記の方法で作成したリソースは、宣言のようなものであり、実際の確保と開放は RDG が利用パスを検出して自動管理します。"}]},{type:a,value:f},{type:b,tag:bX,props:{id:aZ},children:[{type:b,tag:l,props:{href:bs,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:aq}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"もちろん、RDG 以外で確保されたリソースとの連携も可能です。"}]},{type:a,value:f},{type:b,tag:B,props:{className:[P]},children:[{type:b,tag:H,props:{className:[y]},children:[{type:b,tag:n,props:{className:[y]},children:[{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F 外部のテクスチャリソースを RDG リソースとして登録する"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:" FRenderTarget"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:M}]},{type:a,value:" RenderTarget "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:E}]},{type:a,value:" ViewFamily"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:a,value:ca},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:" FRDGTextureRef TinyRendererOutputRef "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:E}]},{type:a,value:T},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"RegisterExternalTexture"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"CreateRenderTarget"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ca},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:aL}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"GetRenderTargetTexture"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,S]},children:[{type:a,value:"\"TinyRendererOutput\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:Y},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F RDG 内部のテクスチャリソースを取り出す"}]},{type:a,value:"\nTRefCountPtr"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:I}]},{type:a,value:"IPooledRenderTarget"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:J}]},{type:a,value:" OutTexture"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:"\nGraphBuilder"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"QueueTextureExtraction"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"RDGResource"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:"OuteTexture"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"外部のリソースはRDGに渡しても、そのまま外部で寿命を管理する必要があります。RDG から取り出したリソースは、スマートポインタとして取得されるので、スマートポインタの寿命が尽きるまでGPUリソースの寿命が延長され、RDGのスコープを考える必要はありません。\n1パスで処理を行う場合にはあまり使いませんが、ヒストリを利用したり、外部のRenderTagetに書き出したい場合などに便利です。"}]},{type:a,value:f},{type:b,tag:G,props:{id:$},children:[{type:b,tag:l,props:{href:bt,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:$}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"RDG を使ってパスを追加するときには、"},{type:b,tag:n,props:{},children:[{type:a,value:cb}]},{type:a,value:" を使うことができます。"}]},{type:a,value:f},{type:b,tag:B,props:{className:[P]},children:[{type:b,tag:H,props:{className:[y]},children:[{type:b,tag:n,props:{className:[y]},children:[{type:a,value:aK},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:M}]},{type:a,value:bZ},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:E}]},{type:a,value:T},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,al]},children:[{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:b_}]},{type:b,tag:c,props:{className:[d,C,am]},children:[{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:I}]},{type:a,value:aK},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:J}]}]}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:"\n\nGraphBuilder"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:cc}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:aJ},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:bV}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,S]},children:[{type:a,value:"\"MyPixelShaderPass\""}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:cd},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"Width"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:cd},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"Height"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:"\n\t\t\tPassParameters"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:"\n\t\t\tERDGPassFlags"},{type:b,tag:c,props:{className:[d,e,K]},children:[{type:a,value:L}]},{type:a,value:"Raster "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:bY}]},{type:a,value:" ERDGPassFlags"},{type:b,tag:c,props:{className:[d,e,K]},children:[{type:a,value:L}]},{type:a,value:"NeverCull"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:aJ},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bR}]},{type:a,value:"ResourceOne"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:" ResourceTwo"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:bS}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"FRHICommandList"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:bT},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:W}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F RHICmdList を操作して、レンダリングパス処理を追加する"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"AddPass にわたすラムダ式は、呼び出し時に RHICmdList が渡されてくるので、ここでは従来どおりRHICmdListを操作して描画処理を記述します。\nもちろん、RHICmdListを操作できるので従来どおり(RDG以前)の操作が自由にかけてしまうのですが、それは RDG Pass の意図ではありません。"}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"RDG Pass では、引数に渡したパスパラメータに含まれる RDG リソースを検出し、GPUリソースの実体の確保を行ってくれます。そのため、"},{type:b,tag:b$,props:{},children:[{type:a,value:"AddPass のラムダの中ではパラメータのリソースを利用した処理を書くこと"}]},{type:a,value:"が望まれます。逆に、本来パスに不要なパラメータを大量に渡してしまったりすると、本来必要ないリソースをパスのために RDG が確保してしまうリスクがあるので注意が必要です。"}]},{type:a,value:f},{type:b,tag:G,props:{id:a_},children:[{type:b,tag:l,props:{href:bu,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:ar}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:b,tag:n,props:{},children:[{type:a,value:cb}]},{type:a,value:" はプリミティブなパス追加機能ですが、頻用の目的に対しては RDG がユーティリティ関数を用意しています。\nいくつかの関数の定義を紹介します。"}]},{type:a,value:f},{type:b,tag:B,props:{className:[P]},children:[{type:b,tag:H,props:{className:[y]},children:[{type:b,tag:n,props:{className:[y]},children:[{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F テクスチャをコピーするパスを追加"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aa}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"AddCopyTexturePass"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:an},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:T},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:"\n\t\t\t\t\tFRDGTextureRef InputTexture"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:"\n\t\t\t\t\tFRDGTextureRef OutputTexture"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:N},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:" FRHICopyTextureInfo"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:" CopyInfo"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F スクリーンパス(指定したViewport全体を処理するパス)を追加する。Pixel Shader 画像を処理するのに便利。"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aM}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:I}]},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:Z}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,C]},children:[{type:a,value:aN}]},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:J}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aa}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"AddDrawScreenPass"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:an},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:T},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:aO},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:ak}]},{type:a,value:aP},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:N},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:ce},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:aF},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:N},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:cf},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:bI},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:N},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:cf},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:" InputViewport"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:N},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:cg},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:I}]},{type:a,value:aN},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:J}]},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:ch},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:N},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:Z}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,C]},children:[{type:a,value:aN}]},{type:b,tag:c,props:{className:[d,e,K]},children:[{type:a,value:L}]},{type:a,value:aE},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:M}]},{type:a,value:" PixelShaderParameters"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:"\n\t\t\t\t\tEScreenPassDrawFlags Flags "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:E}]},{type:a,value:" EScreenPassDrawFlags"},{type:b,tag:c,props:{className:[d,e,K]},children:[{type:a,value:L}]},{type:a,value:"None"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F メッシュパス(メッシュを処理するパス)を追加する。AddMeshBatchesCallback にメッシュ追加を行うコールバックを渡す。"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aM}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:I}]},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:Z}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,C]},children:[{type:a,value:"PassParametersType"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:Z}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,C]},children:[{type:a,value:"AddMeshBatchesCallbackLambdaType"}]},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:J}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aa}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"AddSimpleMeshPass"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:an},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:T},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:"\n\t\t\t\t\tPassParametersType"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:M}]},{type:a,value:" PassParameters"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:N},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:" FScene"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:M}]},{type:a,value:" Scene"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:N},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:ce},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:aF},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:"\n\t\t\t\t\tFInstanceCullingManager "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:M}]},{type:a,value:"InstanceCullingManager"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:aO},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:ak}]},{type:a,value:aP},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:N},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:" FIntRect"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:" ViewPortRect"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:"\n\t\t\t\t\tAddMeshBatchesCallbackLambdaType AddMeshBatchesCallback"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F ComputeShader のパスを追加する。"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aM}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:I}]},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:Z}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,C]},children:[{type:a,value:aQ}]},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:J}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:"inline"}]},{type:a,value:" FRDGPassRef "},{type:b,tag:c,props:{className:[d,C]},children:[{type:a,value:"FComputeShaderUtils"}]},{type:b,tag:c,props:{className:[d,e,K]},children:[{type:a,value:L}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:cc}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:an},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:T},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:aO},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:ak}]},{type:a,value:aP},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:N},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:cg},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:I}]},{type:a,value:aQ},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:J}]},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:" ComputeShader"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:N},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:Z}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,C]},children:[{type:a,value:aQ}]},{type:b,tag:c,props:{className:[d,e,K]},children:[{type:a,value:L}]},{type:a,value:aE},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:M}]},{type:a,value:aI},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:"\n\t\t\t\t\tFIntVector GroupCount"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"RDG では、繰り返し利用するパターンは積極的にユーティリティ化することが推奨されています。パス追加以外の部分にも豊富なユーティリティが内蔵されているので、一度 "},{type:b,tag:n,props:{},children:[{type:a,value:"RenderGraphUtils.h"}]},{type:a,value:ci},{type:b,tag:n,props:{},children:[{type:a,value:"ScreenPass.h"}]},{type:a,value:ci},{type:b,tag:n,props:{},children:[{type:a,value:"SimpleMeshDrawCommandPass.h"}]},{type:a,value:" などは眺めておくとよいでしょう。"}]},{type:a,value:f},{type:b,tag:O,props:{id:aB},children:[{type:b,tag:l,props:{href:bv,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:aB}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"ここまで、シェーダーや描画命令の発行方法を見てきました。いよいよメッシュ表現とそれが描画に投入される流れについて見ていきます。"}]},{type:a,value:f},{type:b,tag:G,props:{id:a$},children:[{type:b,tag:l,props:{href:bw,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:af}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"これはゲームスレッドの UPrimitiveComponent のミラーデータで、レンダースレッドで利用される「シーンに配置されて描画可能なもの」を表すオブジェクトです。\nComponent のタイプごとに存在し、SceneRenderer の要求を受けてメッシュデータをレンダラに提供したりしてくれます。UStaticMeshComponent \u002F FStaticMeshSceneProxy などデータソースとしてメッシュアセットを持つものは、メッシュアセットをソースとしてデータを提供することになります。"}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"UPrimitiveComponent には "},{type:b,tag:n,props:{},children:[{type:a,value:"CreateSceneProxy()"}]},{type:a,value:" という仮想関数が定義されており、描画可能なコンポーネントを実装するときにはこれを実装する必要があります。"}]},{type:a,value:f},{type:b,tag:B,props:{className:[P]},children:[{type:b,tag:H,props:{className:[y]},children:[{type:b,tag:n,props:{className:[y]},children:[{type:a,value:af},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:M}]},{type:a,value:" PrimitiveSceneProxy "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:E}]},{type:a,value:" PrimitiveComponent"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:aL}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"CreateSceneProxy"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:G,props:{id:ba},children:[{type:b,tag:l,props:{href:bx,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:as}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"FPrimitiveSceneProxy から取得されるメッシュデータのバッチです。内部に頂点データやマテリアル、利用すべき VertexFactory など、メッシュのレンダリングに必要なすべての情報を含んでいます。"}]},{type:a,value:f},{type:b,tag:G,props:{id:bb},children:[{type:b,tag:l,props:{href:by,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:at}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"メッシュ描画を扱うパスを定義するクラスです。派生クラスを定義し、MeshBatch, シェーダー, マテリアル取得などのセットアップを記述すると、FMeshDrawCommand というメッシュ描画用の命令を構築してくれます。\nFMeshDrawCommand はあとの段階で更に RHICommand に変換され、レンダリングが実行されます。"}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"動的パスを簡易に実行するだけならば、前述の "},{type:b,tag:n,props:{},children:[{type:a,value:cj}]},{type:a,value:" と組み合わせることで簡単にメッシュ描画パスを実行できます。\n以下はエンジン内の例です。"}]},{type:a,value:f},{type:b,tag:B,props:{className:[ai]},children:[{type:b,tag:B,props:{className:[aj]},children:[{type:a,value:"DepthRendering.cpp"}]},{type:b,tag:H,props:{},children:[{type:b,tag:n,props:{className:[y]},children:[{type:a,value:"AddSimpleMeshPass(GraphBuilder, PassParameters, Scene, View, &InstanceCullingManager, RDG_EVENT_NAME(\"ViewMeshElementsPass\"), View.ViewRect,\n\t[&View, Scene, DrawRenderState, &MeshElements, bRespectUseAsOccluderFlag, DepthDrawingMode](FDynamicPassMeshDrawListContext* DynamicMeshPassContext)\n\t{\n\t\tFDepthPassMeshProcessor PassMeshProcessor(\n\t\t\tEMeshPass::DepthPass,\n\t\t\tView.Family-\u003EScene-\u003EGetRenderScene(),\n\t\t\tView.GetFeatureLevel(),\n\t\t\t&View,\n\t\t\tDrawRenderState,\n\t\t\tbRespectUseAsOccluderFlag,\n\t\t\tDepthDrawingMode,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\tDynamicMeshPassContext);\n\n\t\tconst uint64 DefaultBatchElementMask = ~0ull;\n\n\t\tfor (const FMeshBatch& MeshBatch : MeshElements)\n\t\t{\n\t\t\tPassMeshProcessor.AddMeshBatch(MeshBatch, DefaultBatchElementMask, nullptr);\n\t\t}\n\t}\n);"}]}]}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"FDepthMeshPassProcessor は FMeshPassProcessor の派生です。ここでは "},{type:b,tag:n,props:{},children:[{type:a,value:cj}]},{type:a,value:" の中で、MeshBatchを "},{type:b,tag:n,props:{},children:[{type:a,value:"AddMeshBatch()"}]},{type:a,value:" することで描画コマンドを RHICommandList に追加しています。\nコード上に RHICommandList は直接見えませんが、 "},{type:b,tag:n,props:{},children:[{type:a,value:"DynamicMeshPassContext"}]},{type:a,value:" の中にコンテキストのコマンドリストが保持されており、 FMeshPassProcessor がコマンドを追加してくれます。"}]},{type:a,value:f},{type:b,tag:O,props:{id:"マテリアルとシェーダーレンダースレッド表現"},children:[{type:b,tag:l,props:{href:bz,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:bA}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"ご存知の通り、マテリアルアセットは、ノードベースに GPU で実行されるグラフィックス処理を記述できる機能です。\n当然ですが、 GPU にマテリアルノードを処理する機能は無いので、マテリアルから HLSL コードを生成しています。つまり、マテリアルは単なるグラフィカルなシェーダー言語であるということです。"}]},{type:a,value:f},{type:b,tag:G,props:{id:bc},children:[{type:b,tag:l,props:{href:bB,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:au}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"詳しくは述べませんが、 "},{type:b,tag:n,props:{},children:[{type:a,value:ck}]},{type:a,value:" というクラスが変換を担っています。仕組みとしては、マテリアルのノードから多数の HLSL のコード片を組み立て、 "},{type:b,tag:n,props:{},children:[{type:a,value:"MaterialTemplate.ush"}]},{type:a,value:" というテンプレートファイルに当てはめることでマテリアルのシェーダーを生成しています。"}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"ただし、 "},{type:b,tag:n,props:{},children:[{type:a,value:"MaterialHLSLEmitter"}]},{type:a,value:" という新しい HLSL 生成パイプラインの実装も始まっており、将来的には "},{type:b,tag:n,props:{},children:[{type:a,value:ck}]},{type:a,value:" は非推奨のレガシーになるかもしれません。\n(大量の %s や %d を埋めていくテンプレート方式は正気でないと思っていたので納得ではあります)"}]},{type:a,value:f},{type:b,tag:G,props:{id:bd},children:[{type:b,tag:l,props:{href:bC,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:av}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"これらは普段エディタで操作しているマテリアルアセットを表現しているクラスです。ユーザーに近いクラスで、マテリアルの編集データ及び生成済みのバイナリなどを保持します。\nUMaterial \u002F UMaterialInstance は継承関係にありませんが、どちらも UMaterialInterface というインターフェースを実装しています。　\nゲームスレッドで利用されます。"}]},{type:a,value:f},{type:b,tag:G,props:{id:be},children:[{type:b,tag:l,props:{href:bD,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:aw}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"マテリアルのレンダースレッド表現です。マテリアルパラメータを取得する機能などを実装しています。"}]},{type:a,value:f},{type:b,tag:G,props:{id:bf},children:[{type:b,tag:l,props:{href:bE,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:ax}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"こちらもマテリアルのレンダースレッド表現で、マテリアルの多くの設定やシェーダーマップを保持しています。\nFMaterialRenderProxy との違いがわかりにくいですが、コンポーネントとメッシュアセットの関係に近いです。メッシュアセットはメッシュデータを持ちますが、どこにどのように配置されるかはコンポーネントがデータを保持、決定します。\n同様に、FMaterial \u002F FMaterialResource はマテリアルの基本情報をすべて持っていますが、どのようなパラメータを与えて描画に利用されるかは FMaterialRenderProxy が決定します。"}]},{type:a,value:f},{type:b,tag:O,props:{id:aC},children:[{type:b,tag:l,props:{href:bF,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:aC}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"FMaterialShader の派生として実装したシェーダーであれば、その内部でマテリアルが生成したシェーダーの結果にアクセスすることができます。\nつまり、FMaterialShader のシェーダーとマテリアルの生成したシェーダーとコンパイル時に組み合わせて、新たなシェーダーデータを生成しているということです。\nこれは、次のように書くことで実現できます。"}]},{type:a,value:f},{type:b,tag:B,props:{className:[P]},children:[{type:b,tag:H,props:{className:[y]},children:[{type:b,tag:n,props:{className:[y]},children:[{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F 必要データ"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:" FMaterial"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:" MaterialResource "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:E}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:aR}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:" FMaterialRenderProxy"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:A}]},{type:a,value:" MaterialRenderProxy "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:E}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:aR}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:" FVertexFactory"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:M}]},{type:a,value:" VertexFactory "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:E}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:aR}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:Y},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F HLSL で実装した FMeshMaterialShader の派生シェーダー含んだ ShaderTypes を作成"}]},{type:a,value:"\nFMaterialShaderTypes ShaderTypes"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:cl},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,al]},children:[{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:cm}]},{type:b,tag:c,props:{className:[d,C,am]},children:[{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:I}]},{type:a,value:cn},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:J}]}]}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:cl},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,al]},children:[{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:cm}]},{type:b,tag:c,props:{className:[d,C,am]},children:[{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:I}]},{type:a,value:co},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:J}]}]}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:Y},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F ShaderTypes と VertexFactoryType をもとに、MaterialResource から実際に利用するシェーダーを取得"}]},{type:a,value:"\nFMaterialShaders Shaders"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:z}]},{type:a,value:" FVertexFactoryType"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:M}]},{type:a,value:" VertexFactoryType "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:E}]},{type:a,value:" VertexFactory"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:aL}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"GetType"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:"if"}]},{type:a,value:p},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:"!"}]},{type:a,value:"MaterialResource"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"TryGetShaders"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"ShaderTypes"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:" VertexFactoryType"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:" Shaders"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:W}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F 無効な組み合わせだったり、コンパイルが終わっていなかったりすると失敗する"}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:bO}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:X}]},{type:a,value:"\n\nTShaderRef"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:I}]},{type:a,value:cn},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:J}]},{type:a,value:" VertexShader"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:"\nTShaderRef"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:I}]},{type:a,value:co},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:J}]},{type:a,value:ch},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:Y},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F シェーダーを取り出す"}]},{type:a,value:cp},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"TryGetVertexShader"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"VertexShader"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:cp},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:x}]},{type:b,tag:c,props:{className:[d,m]},children:[{type:a,value:"TryGetPixelShader"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"PixelShader"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:q}]},{type:a,value:Y},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"\u002F\u002F 以降でマテリアル + FMeshMaterialShader のシェーダーを利用できるようになる"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"マテリアルを使ったシェーダーはエンジン改造なしでは書けないと思われることも多い気がするのですが、このようにすればマテリアルの生成したロジックを活用したグラフィック機能をプラグインなどで実装することも可能なのです。"}]},{type:a,value:f},{type:b,tag:O,props:{id:aD},children:[{type:b,tag:l,props:{href:bG,ariaHidden:t,tabIndex:u},children:[{type:b,tag:c,props:{className:[v,w]},children:[]}]},{type:a,value:aD}]},{type:a,value:f},{type:b,tag:h,props:{},children:[{type:a,value:"この記事では、マテリアルをサポートした独自のメッシュパスを追加するために必要な前提知識を整理しました。ここに書いてある内容は、すべてプロジェクトやプラグインから利用可能なものです。\n次回はいよいよ、単一メッシュレンダラの実装を行います。12月中に出せたらいいな！"}]}]},dir:"\u002Farticles\u002Funrealengine",path:cq,extension:".md",createdAt:cr,updatedAt:cr,gitCreatedAt:cs,gitUpdatedAt:cs},path:cq}],fetch:{"data-v-08b63208:0":{prevTitle:ad,nextTitle:ad,existPrev:ct,existNext:ct,prevSlug:ad,nextSlug:ad,seriesPage:ad}},mutations:void 0}}("text","element","span","token","punctuation","\n","operator","p","(",")",",","a","function","code","keyword"," ",";","li","comment","true",-1,"icon","icon-link",".","language-cpp","const","&","div","class-name","\n\t","=",2,"h2","pre","\u003C","\u003E","double-colon","::","*","\n\t\t\t\t\t","h1","remark-highlight","ul","\n\t\t","string"," GraphBuilder","FGlobalShader","FMaterialShader","{","}","\n\n","typename","リソースの作成","基本的なパスの追加","void","TEXT","\n\n\n","","FMeshMaterialShader","FPrimitiveSceneProxy","FShader","FBufferVisualizeShaderPS","code-extra","filename","&&","generic-function","generic","FRDGBuilder","RDG を使った描画命令発行のボイラープレート","RDG によるリソースの取り扱い","RDG 外部とのリソースのやりとり","目的別のRDGパス追加ユーティリティ","FMeshBatch","FMeshPassProcessor","HLSL への変換","UMaterial \u002F UMaterialInstance","FMaterialRenderProxy","FMaterial \u002F FMaterialResource","シェーダーのコンパイル設定","頂点データの受け渡し","グラフィックス命令の発行","メッシュレンダリング","マテリアルをシェーダーで利用する","まとめ","FParameters"," View","ModifyCompilationEnvironment","static"," Parameters","\n\t\t\t","FTinyRendererShaderParameters","-\u003E","template","PixelShaderType","\n\t\t\t\t\tFRDGEventName"," PassName","TShaderClass","\u002F* *\u002F","2023\u002F12\u002F25","fglobalshader","fmaterialshader","fmeshmaterialshader","rdg-を使った描画命令発行のボイラープレート","rdg-によるリソースの取り扱い",3,"rdg-外部とのリソースのやりとり","目的別のrdgパス追加ユーティリティ","fprimitivesceneproxy","fmeshbatch","fmeshpassprocessor","hlsl-への変換","umaterial--umaterialinstance","fmaterialrenderproxy","fmaterial--fmaterialresource","目次","#shader-%E3%81%AF%E3%81%A9%E3%81%86%E3%82%84%E3%81%A3%E3%81%A6%E6%89%B1%E3%82%8F%E3%82%8C%E3%82%8B%E3%81%AE%E3%81%8B","Shader はどうやって扱われるのか？","#fglobalshader","#fmaterialshader","#fmeshmaterialshader","#%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E8%A8%AD%E5%AE%9A","#%E9%A0%82%E7%82%B9%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E5%8F%97%E3%81%91%E6%B8%A1%E3%81%97","#%E3%82%B0%E3%83%A9%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E3%82%B9%E5%91%BD%E4%BB%A4%E3%81%AE%E7%99%BA%E8%A1%8C","#rdg-%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%9F%E6%8F%8F%E7%94%BB%E5%91%BD%E4%BB%A4%E7%99%BA%E8%A1%8C%E3%81%AE%E3%83%9C%E3%82%A4%E3%83%A9%E3%83%BC%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88","#rdg-%E3%81%AB%E3%82%88%E3%82%8B%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%AE%E5%8F%96%E3%82%8A%E6%89%B1%E3%81%84","#%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%AE%E4%BD%9C%E6%88%90","#rdg-%E5%A4%96%E9%83%A8%E3%81%A8%E3%81%AE%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%AE%E3%82%84%E3%82%8A%E3%81%A8%E3%82%8A","#%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E3%83%91%E3%82%B9%E3%81%AE%E8%BF%BD%E5%8A%A0","#%E7%9B%AE%E7%9A%84%E5%88%A5%E3%81%AErdg%E3%83%91%E3%82%B9%E8%BF%BD%E5%8A%A0%E3%83%A6%E3%83%BC%E3%83%86%E3%82%A3%E3%83%AA%E3%83%86%E3%82%A3","#%E3%83%A1%E3%83%83%E3%82%B7%E3%83%A5%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0","#fprimitivesceneproxy","#fmeshbatch","#fmeshpassprocessor","#%E3%83%9E%E3%83%86%E3%83%AA%E3%82%A2%E3%83%AB%E3%81%A8%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%83%AC%E3%83%B3%E3%83%80%E3%83%BC%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E8%A1%A8%E7%8F%BE","マテリアルとシェーダー、レンダースレッド表現","#hlsl-%E3%81%B8%E3%81%AE%E5%A4%89%E6%8F%9B","#umaterial--umaterialinstance","#fmaterialrenderproxy","#fmaterial--fmaterialresource","#%E3%83%9E%E3%83%86%E3%83%AA%E3%82%A2%E3%83%AB%E3%82%92%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC%E3%81%A7%E5%88%A9%E7%94%A8%E3%81%99%E3%82%8B","#%E3%81%BE%E3%81%A8%E3%82%81","\n\n\t"," OutputViewport","FVertexFactory"," OutEnvironment","Parameters","ShouldCompilePermutaion","NAME_LocalVertexFactory","return","==","FVertexFactoryInput","[","]"," RHICmdList","GraphBuilder","RDG_EVENT_NAME","\n\n\t\t\t","h3","|"," PassParameters ","AllocParameters","strong","RenderTarget","GraphBuilder::AddPass()","AddPass"," ViewRect"," FSceneView"," FScreenPassTextureViewport"," TShaderRef"," PixelShader",", ","AddSimpleMeshPass()","FHLSLMaterialTranslator","\nShaderTypes","AddShaderType","FMyMaterialShaderVS","FMyMaterialShaderPS","\nShaders","\u002Farticles\u002Funrealengine\u002Flets-implement-a-single-mesh-renderer-2","2023-12-25T00:00:00.000Z","2023-12-25T13:29:24.000Z",false)));