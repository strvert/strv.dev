__NUXT_JSONP__("/blog/unrealengine--fast-json-serializer-in-unrealengine", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ,aR,aS,aT,aU,aV,aW,aX,aY,aZ,a_,a$,ba,bb,bc,bd,be,bf,bg,bh,bi,bj,bk,bl,bm,bn,bo,bp,bq,br,bs,bt,bu,bv,bw,bx,by,bz,bA,bB,bC,bD,bE,bF,bG,bH,bI,bJ,bK,bL,bM){return {data:[{page:{slug:"fast-json-serializer-in-unrealengine",description:"UHT を使ったコード生成プラグインで、最速(?)クラスの JSON シリアライザを作る話",title:"UHT を拡張して UE 最速(?) 高機能な JSON シリアライザプラグインを作ってみた",enforceCreatedAt:as,enforceUpdatedAt:as,tags:["Unreal Engine","Unreal C++","Blueprint","Advent Calendar"],assets:"\u002Farticle-assets\u002Funrealengine\u002Ffast-json-serializer-in-unrealengine",advent_calendar:{name:"Unreal Engine (UE) Advent Calendar 2024",link:"https:\u002F\u002Fqiita.com\u002Fadvent-calendar\u002F2024\u002Fue",day:25},toc:[{id:at,depth:t,text:_},{id:w,depth:x,text:w},{id:au,depth:t,text:$},{id:av,depth:x,text:w},{id:aw,depth:t,text:aa},{id:H,depth:t,text:H},{id:L,depth:t,text:L},{id:I,depth:t,text:I},{id:ax,depth:t,text:U},{id:J,depth:t,text:J},{id:ay,depth:t,text:V},{id:az,depth:t,text:ab},{id:aA,depth:x,text:ac},{id:M,depth:x,text:M},{id:N,depth:x,text:N},{id:aB,depth:x,text:ad},{id:aC,depth:t,text:ae},{id:aD,depth:x,text:af},{id:aE,depth:x,text:ag},{id:O,depth:t,text:O},{id:aF,depth:t,text:ah},{id:P,depth:t,text:P},{id:Q,depth:t,text:Q}],body:{type:"root",children:[{type:b,tag:F,props:{id:"introduction"},children:[{type:b,tag:g,props:{href:"#introduction",ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:"Introduction"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"コンテンツやサービスの開発を行っていると、 Unreal Engine の上から Web API を呼び出したくなったり、インテグレーションツールとの連携やロギングのためにデータ構造をシリアライズしたくなることがあります。\n幸いなことに、UE には C++ \u002F BP ともに JSON を扱うための機能が提供されています。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"しかし、それらの機能にはいくつかの課題点があります。そこで、今回は UHT (Unreal Header Tool) を拡張して利用することで、最速レベルのパフォーマンス持ちながら標準機能を超える機能性の JSON シリアライザプラグインである "},{type:b,tag:f,props:{},children:[{type:a,value:aG}]},{type:a,value:" を開発してみました。\nエンジン改造は不要で、プラグインとして導入するだけで利用できます。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"GitHub リポジトリ: "},{type:b,tag:g,props:{href:"https:\u002F\u002Fgithub.com\u002Fstrvert\u002FGenJson",rel:[aH,aI,aJ],target:aK},children:[{type:a,value:aG}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"アドカレネタとして 12\u002F23 から書き始めたプラグインなので、まだまだ足りない部分が多く、整備されていない箇所だらけです。\nしかし、わりと面白いものになってきたので、その内容や仕組みについて、利用している UE の機能についても触れながら解説していきたいと思います。"}]},{type:a,value:c},{type:b,tag:F,props:{id:aL},children:[{type:b,tag:g,props:{href:"#%E7%9B%AE%E6%AC%A1",ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:aL}]},{type:a,value:c},{type:b,tag:v,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:g,props:{href:aM},children:[{type:a,value:aN}]}]},{type:a,value:c},{type:b,tag:v,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:g,props:{href:aO},children:[{type:a,value:_}]}]},{type:a,value:c},{type:b,tag:v,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:aP},children:[{type:a,value:w}]}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:g,props:{href:aQ},children:[{type:a,value:$}]}]},{type:a,value:c},{type:b,tag:v,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:g,props:{href:aR},children:[{type:a,value:w}]}]},{type:a,value:c},{type:b,tag:v,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:aS},children:[{type:a,value:ai}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:aT},children:[{type:a,value:aU}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:aV},children:[{type:a,value:aj}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:aW},children:[{type:a,value:ak}]}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:g,props:{href:al},children:[{type:a,value:aX}]}]},{type:a,value:c},{type:b,tag:v,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:aY},children:[{type:a,value:aa}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:aZ},children:[{type:a,value:H}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:a_},children:[{type:a,value:L}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:a$},children:[{type:a,value:I}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:ba},children:[{type:a,value:U}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:bb},children:[{type:a,value:J}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:bc},children:[{type:a,value:V}]}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:g,props:{href:bd},children:[{type:a,value:be}]}]},{type:a,value:c},{type:b,tag:v,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:g,props:{href:bf},children:[{type:a,value:ab}]}]},{type:a,value:c},{type:b,tag:v,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:bg},children:[{type:a,value:ac}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:bh},children:[{type:a,value:M}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:bi},children:[{type:a,value:N}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:bj},children:[{type:a,value:ad}]}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:g,props:{href:bk},children:[{type:a,value:ae}]}]},{type:a,value:c},{type:b,tag:v,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:bl},children:[{type:a,value:af}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:bm},children:[{type:a,value:ag}]}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:g,props:{href:bn},children:[{type:a,value:am}]}]},{type:a,value:c},{type:b,tag:v,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:bo},children:[{type:a,value:O}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:bp},children:[{type:a,value:ah}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:bq},children:[{type:a,value:P}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:g,props:{href:br},children:[{type:a,value:Q}]}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:g,props:{href:bs},children:[{type:a,value:an}]}]},{type:a,value:c}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:F,props:{id:"標準機能の何が不満なのか"},children:[{type:b,tag:g,props:{href:aM,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:aN}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"今回作成したものの解説の前に、標準機能で JSON を操作する際の手法とその良し悪しについて整理しておきます。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"まずはプラグインがどんなものか気になるという人は "},{type:b,tag:g,props:{href:al},children:[{type:a,value:"GenJsonの機能紹介"}]},{type:a,value:" までジャンプしてみてください。"}]},{type:a,value:c},{type:b,tag:u,props:{id:at},children:[{type:b,tag:g,props:{href:aO,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:_}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"UE が提供する低レベルな Json 操作として、 C++ を使って FJsonObject のオブジェクトツリーを直接操作するものがあります。\nこれは以下のように使うことができます。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"FJsonObject を使った JSON 操作"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"\u002F\u002F オブジェクトの作成\nTSharedPtr\u003CFJsonObject\u003E JsonObject = MakeShared\u003CFJsonObject\u003E();\n\n\u002F\u002F プロパティの追加\nJsonObject-\u003ESetNumberField(TEXT(\"score\"), 42);\n\n\u002F\u002F サブオブジェクトの作成と追加\nTSharedPtr\u003CFJsonObject\u003E SubObject = MakeShared\u003CFJsonObject\u003E();\nJsonObject-\u003ESetObjectField(TEXT(\"user\"), SubObject);\n\nSubObject-\u003ESetStringField(TEXT(\"name\"), TEXT(\"douglas\"));\n\n\u002F\u002F JSON 文字列への変換\nFString JsonString;\nTSharedRef\u003CTJsonWriter\u003C\u003E\u003E Writer = TJsonWriterFactory\u003C\u003E::Create(&JsonString);\nFJsonSerializer::Serialize(JsonObject.ToSharedRef(), Writer);"}]}]}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:bt}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[bu]},children:[{type:a,value:"{\n    \"score\": 42,\n    \"user\": {\n        \"name\": \"adams\"\n    }\n}"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"たしかに、この方法であれば基本的なあらゆるデータ操作を行うことができるでしょう。"}]},{type:a,value:c},{type:b,tag:y,props:{id:w},children:[{type:b,tag:g,props:{href:aP,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:w}]},{type:a,value:c},{type:b,tag:v,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:"実現したいデータ構造に対して書き込み処理を手動で行わなければならない"}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:"文字列処理から逃れられず、宣言的でない"}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:"(要するに)とにかく愚直"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"ちょっとした JSON を書き出すだけであれば許容できますが、大量のエンドポイントを備えた API への対応を書きたいときや、複雑なペイロードの合成、仕様変更への追従の容易さなどを考えるとあまりうれしくないでしょう。"}]},{type:a,value:c},{type:b,tag:u,props:{id:au},children:[{type:b,tag:g,props:{href:aQ,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:$}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Unreal Engine には、クラスや構造体の型や名前といった情報を、ビルド後にも残して利用できるようにするためのリフレクション機能が備わっています。\nUE のスクリプト用構造体である USTRUCT(UScriptStruct) は、以下のようなコードによってフィールドの UProperty を列挙したり読み取ったりすることができます。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"サンプル構造体"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"USTRUCT()\nstruct FUserData\n{\n    GENERATED_BODY()\n\n    UPROPERTY()\n    FString UserName;\n\n    UPROPERTY()\n    int32 TotalScore;\n};"}]}]}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"リフレクションによるプロパティの列挙"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"FExampleUserData Struct{\n    \"Orwell\",\n    1984,\n};\n\n\u002F\u002F 型情報オブジェクトを取得\nconst UStruct* StructType = Struct.StaticStruct();\n\n\u002F\u002F リフレクションでプロパティをループして出力\nfor (FProperty* Property : TFieldRange\u003CFProperty\u003E(StructType))\n{\n    \u002F\u002F プロパティの名前を取得\n    FString PropertyName = Property-\u003EGetName();\n    if (const FIntProperty* IntProperty = CastField\u003CFIntProperty\u003E(Property))\n    {\n        \u002F\u002F プロパティの型が int なら値を取得\n        const int32 Value = IntProperty-\u003EGetPropertyValue(Property-\u003EContainerPtrToValuePtr\u003Cint32\u003E(&Struct));\n        UE_LOG(LogTemp, Log, TEXT(\"%s: %d\"), *PropertyName, Value);\n    }\n    else if (const FStrProperty* StrProperty = CastField\u003CFStrProperty\u003E(Property))\n    {\n        \u002F\u002F プロパティの型が FString なら値を取得\n        FString Value = StrProperty-\u003EGetPropertyValue(Property-\u003EContainerPtrToValuePtr\u003CFString\u003E(&Struct));\n        UE_LOG(LogTemp, Log, TEXT(\"%s: %s\"), *PropertyName, *Value);\n    }\n}"}]}]}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:z}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[A]},children:[{type:a,value:"LogTemp: Name: Orwell\nLogTemp: Age: 1984"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"これを利用した JSON シリアライザが FJsonObjectConverter です。\nFJsonObjectConverter は、USTRUCT でデータ構造を宣言しておくだけで、その UProperty を自動で読み取って適切な JSON 型でシリアライズしてくれます。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"USTRUCT を JSON にシリアライズ"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"FUserData UserData{\n    \"Orwell\",\n    1984,\n};\nconst UStruct* StructType = UserData.StaticStruct();\n\nconst TSharedRef\u003CFJsonObject\u003E JsonObject = MakeShared\u003CFJsonObject\u003E();\nFJsonObjectConverter::UStructToJsonObject(StructType, &UserData, JsonObject);\n\nFString JsonString;\nTSharedRef\u003CTJsonWriter\u003C\u003E\u003E Writer = TJsonWriterFactory\u003C\u003E::Create(&JsonString);\nFJsonSerializer::Serialize(JsonObject, Writer);"}]}]}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:bt}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[bu]},children:[{type:a,value:"{\n    \"UserName\": \"Orwell\",\n    \"TotalScore\": 1984\n}"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"こちらはそこそこ良い方法といえます。外部に JSON として吐き出すためのデータ構造が構造体として定義されていて明確ですし、JSON のプロパティの名前を手動で書いたりする必要もありません。\nデータ構造の仕様が変わったら、構造体の定義を変更するだけで済みます。また、書き出し処理はあらゆる USTRUCT に対して使えるため、再利用性が高いです。"}]},{type:a,value:c},{type:b,tag:y,props:{id:av},children:[{type:b,tag:g,props:{href:aR,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:w}]},{type:a,value:c},{type:b,tag:v,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:"JSON のプロパティ名を柔軟に変更(ケース変換とか)できない。"}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:"リフレクション情報の FName を文字列化して利用している。"}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:"特定の構造体のシリアライズをカスタムしたりすることができない。"}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:"実行時にリフレクション情報を読み出して利用しており、JSON オブジェクトを構築する前段階のコストが存在する。"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"こちらの不満は、主に拡張性とオーバーヘッドに関するものです。ややこしい内容が多いので項目ごとに説明していきます。"}]},{type:a,value:c},{type:b,tag:W,props:{id:ai},children:[{type:b,tag:g,props:{href:aS,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:ai}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"プロパティ名の変更や上書きができないのは時に致命的です。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"なぜなら、UE のプロパティの命名規則は "},{type:b,tag:f,props:{},children:[{type:a,value:bv}]},{type:a,value:" なのに対し、世の中の JSON を喋るシステムは必ずしもそうとは限らず、むしろ "},{type:b,tag:f,props:{},children:[{type:a,value:X}]},{type:a,value:" や "},{type:b,tag:f,props:{},children:[{type:a,value:bw}]},{type:a,value:" を採用しているシステムのが多いからです。\nこれに対処するには USTRUCT のプロパティ名を、Unreal C++ の命名規則を無視して "},{type:b,tag:f,props:{},children:[{type:a,value:X}]},{type:a,value:" などで書くことになりますが、気分が悪いのであまりやりたくないでしょう。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"こんなのが混ざっていたら嫌"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"USTRUCT()\nstruct FUserData\n{\n    GENERATED_BODY()\n\n    UPROPERTY()\n    FString user_name;\n\n    UPROPERTY()\n    int32 total_score;\n};"}]}]}]},{type:a,value:c},{type:b,tag:W,props:{id:"リフレクション情報の-fname-を文字列化して利用している"},children:[{type:b,tag:g,props:{href:aT,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:aU}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"実行時のリフレクション情報において、プロパティ名は "},{type:b,tag:f,props:{},children:[{type:a,value:B}]},{type:a,value:" で持たれます。JSON シリアライズでは、これを FString に変換した結果を利用してシリアライズを行います。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"問題は、"},{type:b,tag:f,props:{},children:[{type:a,value:B}]},{type:a,value:" は case-insensitive、すなわち格納した文字列の大文字小文字を区別しない型であること、また、同じ名前の "},{type:b,tag:f,props:{},children:[{type:a,value:B}]},{type:a,value:" がエンジン上で複数回作成されたとしても、先に作成されたほうの "},{type:b,tag:f,props:{},children:[{type:a,value:B}]},{type:a,value:" インスタンスが使い回されることです。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"これが何を意味するかというと、 "},{type:b,tag:f,props:{},children:[{type:a,value:B}]},{type:a,value:" は以下のように、意図したのと違う文字列が "},{type:b,tag:f,props:{},children:[{type:a,value:"FString"}]},{type:a,value:" として取得されるケースがあるということです。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"FNameの罠"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"const FName First = TEXT(\"Neuromancer\");\n\u002F\u002F \"Neuromancer\" と出力されることを期待する。(多くの場合)そのとおりになる。\nUE_LOG(LogTemp, Log, TEXT(\"%s\"), *First.ToString());\n\nconst FName Second = TEXT(\"NEUROMANCER\");\n\u002F\u002F \"NEUROMANCER\" と出力されることを期待するが……？\nUE_LOG(LogTemp, Log, TEXT(\"%s\"), *Second.ToString());"}]}]}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:z}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[A]},children:[{type:a,value:"LogTemp: Neuromancer\nLogTemp: Neuromancer"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"ケース違いの "},{type:b,tag:f,props:{},children:[{type:a,value:B}]},{type:a,value:" は、内部のテーブルに先に格納されたほうの値が再利用されてしまっていることがわかります。なおこの挙動、エディタ上では発生せず、パッケージングすると取得される文字列がまとまるので、罠になりやすいです。(FName を比較以外に使うな)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"UProperty の実行時リフレクションが "},{type:b,tag:f,props:{},children:[{type:a,value:B}]},{type:a,value:" から取得された文字列に基づくということは、この方法を用いた JSON 生成では、パッケージング後のフィールド名が本質的に予測不能であるということです。\nたまたまケース違いの "},{type:b,tag:f,props:{},children:[{type:a,value:B}]},{type:a,value:" が先に作成されているだけで、シリアライズ結果が変わってしまいます。"}]},{type:a,value:c},{type:b,tag:W,props:{id:aj},children:[{type:b,tag:g,props:{href:aV,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:aj}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"データ構造や用途によって、特定の構造体に対してだけシリアライズ処理を上書きしたいということがあります。\n例えば、特定の構造体に対しては、特定のプロパティを無視したり、特定のプロパティの値を変換したり、特定のプロパティを特定の条件下でシリアライズしたりといったことが考えられます。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"特定の構造体に対してだけ特別な処理を行いたい"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:bx}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"たとえば、この構造体は "},{type:b,tag:f,props:{},children:[{type:a,value:"{\"X\": 0.0, \"Y\": 1.0, \"Z\": 2.0}"}]},{type:a,value:" ではなく、 "},{type:b,tag:f,props:{},children:[{type:a,value:"[0.0, 1.0, 2.0]"}]},{type:a,value:" という配列形式にしたいかもしれません。\nこのような場合にはカスタムシリアライザを実装したいですが、 FJsonObjectConverter ではそのようなことはできません。"}]},{type:a,value:c},{type:b,tag:W,props:{id:ak},children:[{type:b,tag:g,props:{href:aW,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:ak}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"また、リフレクション情報を利用して JSON オブジェクトを構築するというのは、その分のオーバーヘッドがあります。\n"},{type:b,tag:g,props:{href:"#ustuct-%E3%81%AE%E3%83%AA%E3%83%95%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%9F-json-%E6%9B%B8%E3%81%8D%E5%87%BA%E3%81%97"},children:[{type:a,value:"USTRUCT のリフレクションを使った JSON シリアライズ"}]},{type:a,value:" で小規模なプロパティ列挙のループを示しました。\nFJsonObjectConverter では、あらゆるプロパティの種類である可能性を検証して、それに応じた処理を行うため、その分のオーバーヘッドが発生します。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"構造体から愚直にメンバを指定して JSON オブジェクトを構築するのと比べると、どうしても遅くなってしまいます。"}]},{type:a,value:c},{type:b,tag:F,props:{id:"genjson-の機能紹介"},children:[{type:b,tag:g,props:{href:al,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:aX}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"さて、ここからは GenJson の機能を紹介していきます。 GenJson は、上記の不満を踏まえて開発したもので、以下のような特徴を持っています。"}]},{type:a,value:c},{type:b,tag:v,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:"USTRUCT にメタ指定子を与えるだけで、JSON シリアライズ機能を利用可能"}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:H}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:"シリアライズ関数のコード生成による、リフレクション情報不要の高速シリアライズ"}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:I}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:U}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:J}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:a,value:V}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:u,props:{id:aw},children:[{type:b,tag:g,props:{href:aY,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:aa}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"GenJson は、USTRUCT に "},{type:b,tag:f,props:{},children:[{type:a,value:G}]},{type:a,value:" のようにメタ指定子を与えるだけで、その構造体を JSON シリアライズ可能にします。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"USTRUCT に Serialize を与えるだけで JSON シリアライズ可能"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"USTRUCT(meta = (Serialize))\nstruct FUserData\n{\n    GENERATED_BODY()\n\n    UPROPERTY()\n    FString UserName;\n\n    UPROPERTY()\n    int32 TotalScore;\n};"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"次のように利用します。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"シリアライズの実行"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"\u002F\u002F 書き込みたいデータ\nFUserData UserData{\n    .UserName = TEXT(\"Huxley\"),\n    .TotalScore = 1932,\n};\n\n\u002F\u002F Writer の初期化\nGenJson::FRapidJsonStringBuffer StringBuffer;\nGenJson::FJsonWriter Writer{StringBuffer};\n\n\u002F\u002F シリアライズ\nGenJson::Write(UserData, Writer);\n\n\u002F\u002F JSON 文字列を出力\nUE_LOG(LogTemp, Log, TEXT(\"%s\"), *GenJson::ToString(StringBuffer));"}]}]}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:z}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[A]},children:[{type:a,value:"LogTemp: {\"UserName\":\"Huxley\",\"TotalScore\":1932}"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"きちんと JSON にシリアライズされていることがわかります。標準のリフレクションを用いた方法と同等の結果が得られていますが、実行時にリフレクション情報は参照しておらず、オーバーヘッドは発生していません。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"なお、この機能を利用するには、構造体の定義されているヘッダファイルの上部に以下のようなインクルードを追加する必要があります。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[Y]},children:[{type:b,tag:k,props:{className:[r]},children:[{type:b,tag:f,props:{className:[r]},children:[{type:b,tag:e,props:{className:[j,"macro","property"]},children:[{type:b,tag:e,props:{className:[j,"directive-hash"]},children:[{type:a,value:"#"}]},{type:b,tag:e,props:{className:[j,ao,"directive"]},children:[{type:a,value:"include"}]},{type:a,value:C},{type:b,tag:e,props:{className:[j,ap]},children:[{type:a,value:"\"[HeaderName].genjson.h\""}]}]},{type:a,value:c}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"また、ファイルの末尾で以下のマクロを呼び出す必要があります。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[Y]},children:[{type:b,tag:k,props:{className:[r]},children:[{type:b,tag:f,props:{className:[r]},children:[{type:b,tag:e,props:{className:[j,R]},children:[{type:a,value:by}]},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:D}]},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:E}]},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:Z}]},{type:a,value:c}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{},children:[{type:a,value:G}]},{type:a,value:" を持っている構造体同士であれば、ネストされた構造体もシリアライズ可能です。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"複数の構造体を含む構造体"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"USTRUCT(meta = (Serialize))\nstruct FUserData\n{\n    GENERATED_BODY()\n\n    UPROPERTY()\n    FString UserName;\n\n    UPROPERTY()\n    int32 TotalScore;\n};\n\nUSTRUCT(meta = (Serialize))\nstruct FUser\n{\n    GENERATED_BODY()\n\n    UPROPERTY()\n    bool IsAdmin;\n\n    UPROPERTY()\n    FUserData Data;\n};"}]}]}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:z}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[A]},children:[{type:a,value:"LogTemp: {\"IsAdmin\":true,\"Data\":{\"UserName\":\"Huxley\",\"TotalScore\":1932}}"}]}]}]},{type:a,value:c},{type:b,tag:u,props:{id:H},children:[{type:b,tag:g,props:{href:aZ,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:H}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"GenJson では、プロパティ名のケース変換や上書きが可能です。以下のように、"},{type:b,tag:f,props:{},children:[{type:a,value:"meta = (RenameAll = \"snake_case\")"}]},{type:a,value:" を UPROPERTY に与えることで、プロパティ名を "},{type:b,tag:f,props:{},children:[{type:a,value:X}]},{type:a,value:" に変換します。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[Y]},children:[{type:b,tag:k,props:{className:[r]},children:[{type:b,tag:f,props:{className:[r]},children:[{type:b,tag:e,props:{className:[j,R]},children:[{type:a,value:bz}]},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:D}]},{type:a,value:aq},{type:b,tag:e,props:{className:[j,S]},children:[{type:a,value:T}]},{type:a,value:C},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:D}]},{type:a,value:bA},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:","}]},{type:a,value:" RenameAll "},{type:b,tag:e,props:{className:[j,S]},children:[{type:a,value:T}]},{type:a,value:C},{type:b,tag:e,props:{className:[j,ap]},children:[{type:a,value:"\"snake_case\""}]},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:E}]},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:E}]},{type:a,value:c},{type:b,tag:e,props:{className:[j,ao]},children:[{type:a,value:bB}]},{type:a,value:C},{type:b,tag:e,props:{className:[j,bC]},children:[{type:a,value:bD}]},{type:a,value:c},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:bE}]},{type:a,value:bF},{type:b,tag:e,props:{className:[j,bG]},children:[{type:a,value:bH}]},{type:a,value:c},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:bI}]},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:Z}]},{type:a,value:c}]}]}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:z}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[A]},children:[{type:a,value:"LogTemp: {\"user_name\":\"Huxley\",\"total_score\":1932}"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"自動でケース変換されていることがわかります。ケース変換による追加コストは一切発生しません。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"利用可能なケースは以下の 4 つです。"}]},{type:a,value:c},{type:b,tag:v,props:{},children:[{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:f,props:{},children:[{type:a,value:X}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:f,props:{},children:[{type:a,value:bw}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:f,props:{},children:[{type:a,value:bv}]}]},{type:a,value:c},{type:b,tag:i,props:{},children:[{type:b,tag:f,props:{},children:[{type:a,value:"kebab-case"}]}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"また、"},{type:b,tag:f,props:{},children:[{type:a,value:"meta = (Rename = \"new_name\")"}]},{type:a,value:" を UPROPERTY に与えることで、プロパティ名を上書きすることもできます。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[Y]},children:[{type:b,tag:k,props:{className:[r]},children:[{type:b,tag:f,props:{className:[r]},children:[{type:b,tag:e,props:{className:[j,R]},children:[{type:a,value:bz}]},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:D}]},{type:a,value:aq},{type:b,tag:e,props:{className:[j,S]},children:[{type:a,value:T}]},{type:a,value:C},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:D}]},{type:a,value:bA},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:E}]},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:E}]},{type:a,value:c},{type:b,tag:e,props:{className:[j,ao]},children:[{type:a,value:bB}]},{type:a,value:C},{type:b,tag:e,props:{className:[j,bC]},children:[{type:a,value:bD}]},{type:a,value:c},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:bE}]},{type:a,value:bF},{type:b,tag:e,props:{className:[j,R]},children:[{type:a,value:"GENERATED_BODY"}]},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:D}]},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:E}]},{type:a,value:bJ},{type:b,tag:e,props:{className:[j,R]},children:[{type:a,value:"UPROPERTY"}]},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:D}]},{type:a,value:aq},{type:b,tag:e,props:{className:[j,S]},children:[{type:a,value:T}]},{type:a,value:C},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:D}]},{type:a,value:"Rename "},{type:b,tag:e,props:{className:[j,S]},children:[{type:a,value:T}]},{type:a,value:C},{type:b,tag:e,props:{className:[j,ap]},children:[{type:a,value:"\"USERRRRRNAME\""}]},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:E}]},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:E}]},{type:a,value:"\n    FString UserName"},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:Z}]},{type:a,value:bJ},{type:b,tag:e,props:{className:[j,bG]},children:[{type:a,value:bH}]},{type:a,value:c},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:bI}]},{type:b,tag:e,props:{className:[j,s]},children:[{type:a,value:Z}]},{type:a,value:c}]}]}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:z}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[A]},children:[{type:a,value:"LogTemp: {\"USERRRRRNAME\":\"Huxley\",\"TotalScore\":1932}"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"サポートされていないケースにしたいときや、特定のプロパティ名を変更したいときに便利です。"}]},{type:a,value:c},{type:b,tag:u,props:{id:L},children:[{type:b,tag:g,props:{href:a_,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:L}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"エンジンの USTRUCT 自動シリアライザは、リフレクション情報の読み出しが余計なオーバーヘッドとなっていました。\nGenJson では、 "},{type:b,tag:f,props:{},children:[{type:a,value:G}]},{type:a,value:" の指定を受けた USTRUCT に対して、以下のようなシリアライズ関数を自動生成します。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"自動生成されるシリアライズ関数"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"template \u003C\u003E\nstruct GenJson::TSerializer\u003C::FUserData\u003E\n{\n\tstatic bool Write(const FUserData& Instance, FJsonWriter& Writer)\n\t{\n\t\tWriter.StartObject();\n\t\tWriter.Key(TEXT(\"UserName\"));\n\t\tGenJson::Write(Instance.UserName, Writer);\n\t\tWriter.Key(TEXT(\"TotalScore\"));\n\t\tGenJson::Write(Instance.TotalScore, Writer);\n\t\tWriter.EndObject();\n\t\treturn true;\n\t}\n};"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"リフレクション情報を利用せず、ハードコードされたプロパティ名と型を利用してシリアライズを行うため、オーバーヘッドなしで高速なシリアライズが可能です。\nGenJson がシリアライズ処理を試みるとき、目的の型に対してこのようなシリアライズ関数が存在するかを探し、存在する場合はそれを利用します。\nそのため、"},{type:b,tag:f,props:{},children:[{type:a,value:G}]},{type:a,value:" を与えた USTRUCT に対しては、統一した API でシリアライズを行うことができます。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"統一されたシリアライズの実行"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"\u002F\u002F 書き込み関数はテンプレート化されていて、 Serialize が実装された任意の構造体を受け取ることができる。\ntemplate \u003Ctypename T\u003E\nbool Write(const T& StructInstance, FJsonWriter& Writer)"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"また、見ての通り生成されるシリアライズ関数は static 関数であり、継承や仮想関数を利用していません。コンパイル時に適切な関数が静的に選択されるため、呼び出しにも関数呼び出し以上のオーバーヘッドは発生しません。"}]},{type:a,value:c},{type:b,tag:u,props:{id:I},children:[{type:b,tag:g,props:{href:a$,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:I}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"シリアライズ関数をカスタマイズしたい場合、 "},{type:b,tag:f,props:{},children:[{type:a,value:G}]},{type:a,value:" でコードを生成させずに、以下の形式でシリアライズ関数を書いておけば、 GenJson はその関数を発見して利用します。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"対象の構造体"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:bx}]}]}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"カスタムシリアライズ関数の実装"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"template \u003C\u003E\nstruct GenJson::TSerializer\u003CFMyVector\u003E\n{\n    static bool Write(const FMyVector& Instance, FJsonWriter& Writer)\n    {\n        Writer.StartArray();\n        GenJson::Write(Instance.X, Writer);\n        GenJson::Write(Instance.Y, Writer);\n        GenJson::Write(Instance.Z, Writer);\n        Writer.EndArray();\n        return true;\n    }\n};"}]}]}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:z}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[A]},children:[{type:a,value:"LogTemp: [0.0, 1.0, 2.0]"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"カスタムしたい構造体は Serialize を付与せずに、代わりに上記の形式のシリアライズ関数を実装しておくだけで、その構造体に対してカスタムシリアライズが行われます。"}]},{type:a,value:c},{type:b,tag:u,props:{id:ax},children:[{type:b,tag:g,props:{href:ba,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:U}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"GenJson は UENUM にも対応しています。以下のように、"},{type:b,tag:f,props:{},children:[{type:a,value:G}]},{type:a,value:" を UENUM に与えることで、その列挙体を JSON シリアライズ可能にします。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"UENUM に Serialize で JSON シリアライズ可能に"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"UENUM(meta = (Serialize))\nenum class ERarity : uint8\n{\n    Rare, \u002F\u002F → \"Rare\"\n    SuperRare, \u002F\u002F → \"SuperRare\"\n    UltraRare \u002F\u002F → \"UltraRare\"\n};"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"また、UENUM のプロパティ名のケース変換や上書きも可能です。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"UENUM に RenameAll でケース変換"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"UENUM(meta = (Serialize, RenameAll = \"snake_case\"))\nenum class ERarity : uint8\n{\n    Rare, \u002F\u002F → \"rare\"\n    SuperRare, \u002F\u002F → \"super_rare\"\n    UltraRare \u002F\u002F → \"ultra_rare\"\n};"}]}]}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"UENUM に Rename でプロパティ名上書き"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"UENUM(meta = (Serialize))\nenum class ERarity : uint8\n{\n    Rare UPARAM(meta = (Rename = \"Rare\")), \u002F\u002F → \"Rare\"\n    SuperRare UPARAM(meta = (Rename = \"Super_Rare\")), \u002F\u002F → \"Super_Rare\"\n    UltraRare UPARAM(meta = (Rename = \"Ultra_Rare\")) \u002F\u002F → \"Ultra_Rare\"\n};"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"UENUM 専用の機能として、文字列ではなく数値でシリアライズすることも可能です。数値としてシリアライズしたい場合には "},{type:b,tag:f,props:{},children:[{type:a,value:"meta = (AsNumber)"}]},{type:a,value:" を追加で与えます。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"UENUM に AsNumber で数値シリアライズ"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"UENUM(meta = (Serialize, AsNumber))\nenum class ERarity : uint8\n{\n    Rare = 0, \u002F\u002F → 0\n    SuperRare, \u002F\u002F → 1\n    UltraRare \u002F\u002F → 2\n};"}]}]}]},{type:a,value:c},{type:b,tag:u,props:{id:J},children:[{type:b,tag:g,props:{href:bb,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:J}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"コード生成や独自の指定子などを実装していますが、エンジン改造は不要です。プラグインとして導入するだけで手軽に利用することができます。"}]},{type:a,value:c},{type:b,tag:u,props:{id:ay},children:[{type:b,tag:g,props:{href:bc,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:V}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"GenJson は、高速な JSON ライブラリである RapidJson をベースにしています。GenJson が UHT を使って生成するコードは、 RapidJson の API を利用しているため、JSON の操作自体も高速です。\nRapidJson は UE に標準で含まれているものを利用しているので、追加のライブラリの導入は不要です。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:g,props:{href:"https:\u002F\u002Frapidjson.org\u002F",rel:[aH,aI,aJ],target:aK},children:[{type:a,value:"RapidJson"}]}]},{type:a,value:c},{type:b,tag:F,props:{id:"genjson-の仕組みと関連-ue-機能の解説"},children:[{type:b,tag:g,props:{href:bd,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:be}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"この節では、GenJson の仕組みを解説しながら、それに利用した Unreal Engine の機能についても触れていきたいと思います。"}]},{type:a,value:c},{type:b,tag:u,props:{id:az},children:[{type:b,tag:g,props:{href:bf,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:ab}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"機能紹介でも示した通り、 GenJson では、 USTRUCT や UPROPERTY にメタ指定子を与えるだけで、実行時に利用可能なシリアライズ機能を制御することができます。\nメタ指定子とはどのようなものなのかを見てみましょう。"}]},{type:a,value:c},{type:b,tag:y,props:{id:aA},children:[{type:b,tag:g,props:{href:bg,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:ac}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"meta を説明するために、リフレクションに簡単に触れておきます。リフレクションとは、本来であればコンパイル時に消失してしまい、実行時にはアクセスできないような「ソースコードやプログラムたちそれ自身の情報」を、実行時に利用可能にする機能です。\nC# などの言語では、標準でリフレクションがサポートされており、実行時に型情報やメソッド情報を取得したり、それに基づいてインスタンスを生成したりすることができます。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"C++ には本来リフレクション機能がありませんが、 Unreal Engine は独自のリフレクションシステムを持っています。その中核を担うのが、 UHT (Unreal Header Tool) です。\nUnreal Engine のリフレクションシステムは、以下のようなプロセスで機能しています。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:"img",props:{alt:K,src:"\u002Farticle-assets\u002Funrealengine\u002Ffast-json-serializer-in-unrealengine\u002F\u002Freflection-flow.png"},children:[]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"UCLASS や USTRUCT, UPROPERTY といった独自マクロは、 UHT (Unreal Header Tool) がパースして解釈します。"},{type:b,tag:"br",props:{},children:[]},{type:a,value:"\nUHT は解釈した情報をもとに、プロジェクトに追加の C++ コードを生成します。コンパイルされるコードは、ユーザーが書いた C++ コードと UHT によって生成されたコードが組み合わさっています。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"UHT が生成したコードには、各クラスやプロパティについてのリフレクション情報が埋め込まれています。この情報を利用することで、実行時のリフレクションが成立しているのです。"}]},{type:a,value:c},{type:b,tag:y,props:{id:M},children:[{type:b,tag:g,props:{href:bh,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:M}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"メタ指定子も、UHT が解釈し、リフレクション情報に含まれるようになっています。ですから、以下のようにすることで、実行時に "},{type:b,tag:f,props:{},children:[{type:a,value:ar}]},{type:a,value:" に渡した情報にアクセスすることができるのです。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"メタ指定子を持った USTRUCT"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"USTRUCT(meta = (Serialize))\nstruct FUserData\n{\n    GENERATED_BODY()\n\n    UPROPERTY(meta = (Rename = \"USERRRRRNAME\"))\n    FString UserName;\n\n    UPROPERTY()\n    int32 TotalScore;\n};"}]}]}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"メタ指定子の情報を取得"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"const UStruct* StructType = FUserData::StaticStruct();\nif (StructType-\u003EHasMetaData(TEXT(\"Serialize\")))\n{\n    UE_LOG(LogTemp, Log, TEXT(\"Serialize 指定あり: %s\"), *StructType-\u003EGetName());\n}\n\nfor (FPorperty* Property : TFieldRange\u003CFProperty\u003E(StructType))\n{\n    if (Property-\u003EHasMetaData(TEXT(\"Rename\")))\n    {\n        UE_LOG(LogTemp, Log, TEXT(\"Rename: %s to %s\"), *Property-\u003EGetName(), *Property-\u003EGetMetaData(TEXT(\"Rename\")));\n    }\n}"}]}]}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:z}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[A]},children:[{type:a,value:"LogTemp: Serialize 指定あり: FUserData\nLogTemp: Rename: UserName to USERRRRRNAME"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:b,tag:f,props:{},children:[{type:a,value:ar}]},{type:a,value:" の中に書けるものにルールはないので、好きな情報を Key-Value の形式でプロパティに付加することができます。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"これは大変便利で、プロパティに関する周辺機能の振る舞いを、メタ指定子の情報に基づいて切り替えることができるということになります。実際、UE のエディタ内でもよく利用されており、meta の記載によってエディタ上でのプロパティの見た目が変わったりすることがあります。"}]},{type:a,value:c},{type:b,tag:y,props:{id:N},children:[{type:b,tag:g,props:{href:bi,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:N}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"プロパティの名前、型といった基本的な情報は、UHT が埋め込んだ情報をもとにパッケージング後も利用可能です。標準の USTRUCT → JSON シリアライザも、この情報に基づいて機能しています。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"しかし、 "},{type:b,tag:f,props:{},children:[{type:a,value:ar}]},{type:a,value:" で与えるメタ指定子は、その情報がパッケージングで消失してしまいます。その仕組みは単純で、 meta のリフレクション情報を格納している "},{type:b,tag:f,props:{},children:[{type:a,value:"MetaData"}]},{type:a,value:" というプロパティは、エディタ向けビルド以外ではコンパイルに含まれないようになっているからです。"}]},{type:a,value:c},{type:b,tag:h,props:{className:[p]},children:[{type:b,tag:h,props:{className:[q]},children:[{type:a,value:"MetaData の定義の引用"}]},{type:b,tag:k,props:{},children:[{type:b,tag:f,props:{className:[r]},children:[{type:a,value:"#if WITH_METADATA\n\t\u002F\u002F MetaData for the editor, or NULL in the game\n\tclass UMetaData* MetaData;\n#endif \u002F\u002F WITH_METADATA"}]}]}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"プリプロセッサマクロで切り替えられており、コードごと消えてしまうので、 C++ だけではどうやっても meta に書いた情報をパッケージング後に利用することはできません。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"しかしながら、エディタが利用しているメタ指定子を眺めていると、その一部はどうもパッケージング後の挙動にも影響を与えるものがあるように見えてきます。C++ ではこれは不可能なはずですから、より上位の構造がこれを実現しているはずです。どうなっているのでしょうか？"}]},{type:a,value:c},{type:b,tag:y,props:{id:aB},children:[{type:b,tag:g,props:{href:bj,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:ad}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"リフレクションのためのコード情報を生成しているのは UHT であると説明しました。 UHT は、C++ コンパイラよりも前に Unreal C++ のコードをパースして解釈します。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"その過程で、UHT は UCLASS や UPROPERTY に記述された情報にアクセスすることができます。もちろん、そこにはメタ指定子も含まれます。つまり、メタ指定子の中の値に応じて、UHT は生成するコードを変えることができるのです。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"UHT が利用しないメタデータに関してはそのまま MetaData 構造体に埋め込まれるだけで、それ以外の UHT の処理には関与しません。これではパッケージングで消えてしまい、コンテンツ機能から利用できません。  ならば、UHT を拡張して、パッケージング後にも残るような形でコード上に meta に由来する情報を残せれば、コンテンツ機能から活用することができるでしょう！"}]},{type:a,value:c},{type:b,tag:u,props:{id:aC},children:[{type:b,tag:g,props:{href:bk,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:ae}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"GenJson の機能紹介でも述べた通り、 GenJson は UHT を拡張して、 meta の指定による JSON シリアライズ関数生成機能を提供しています。\nこの機能は、 UBT プラグインというメカニズムを利用しています。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"UBT プラグインは、 UBT および UHT の機能を拡張するための UBT の機能です。 UBT プラグインを使うと、 UHT がパースした C++ コードや UE の独自マクロの情報を使って、新たなコードを生成したり、解析を行ったりすることができます。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"UBT プラグインの作り方については、また別の記事にしたいと思いますが、ここでは GenJson が UBT プラグインを使ってどのような JSON シリアライズ関数を生成し、利用しているのかを見ていきましょう。"}]},{type:a,value:c},{type:b,tag:y,props:{id:aD},children:[{type:b,tag:g,props:{href:bl,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:af}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"GenJson は、 meta = (Serialize) が指定された USTRUCT もしくは UENUM がある場合、そのファイルに対応する "},{type:b,tag:f,props:{},children:[{type:a,value:".genjson.h"}]},{type:a,value:" というファイルを生成します。\nUE 標準のリフレクション機能で言うところの "},{type:b,tag:f,props:{},children:[{type:a,value:".generated.h"}]},{type:a,value:" と同じ立ち位置です。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"このファイルには、そのファイルに存在する "},{type:b,tag:f,props:{},children:[{type:a,value:G}]},{type:a,value:" が指定された USTRUCT や UENUM に対応したシリアライズ関数が記述されています。\nただ、シリアライズ関数はその場で定義されているのではなくて、「自動生成されたシリアライズ関数を埋め込むためのマクロ」が定義されます。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"そのマクロが "},{type:b,tag:f,props:{},children:[{type:a,value:by}]},{type:a,value:" です。\nこれを、ファイルの末尾で呼び出すことで、そのファイルに存在するシリアライズ関数が埋め込まれます。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"末尾に追加する必要があるのは、シリアライズ処理には構造体の完全な定義が必要であるためです。"}]},{type:a,value:c},{type:b,tag:y,props:{id:aE},children:[{type:b,tag:g,props:{href:bm,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:ag}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"GenJson は、シリアライズ関数の選択において、テンプレートメタプログラミングの手法である SFINAE を利用しています。\nSFINAE は、関数テンプレートの特殊化を使って、コンパイル時に関数の選択を行う手法です。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"GenJson のシリアライズプロセスでは、GenJson が生成したシリアライズ関数か、ユーザーが記述したシリアライズ関数かを区別していません。\nどちらも SFINE によって最も一致度が高いと判断された関数が選択されます。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"このため、ユーザーによるシリアライズ関数のカスタマイズが容易に行えるという特徴があります。この点は、 UE や UHT の機能を使っているわけではなく、純粋に C++ のテクニックによって実現されています。"}]},{type:a,value:c},{type:b,tag:F,props:{id:am},children:[{type:b,tag:g,props:{href:bn,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:am}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"GenJson は、アドカレネタとして 12\u002F23 から実装を開始した超ホット(?)なプラグインです。まだまだ実装途中で、以下のような機能や検証が実現できていません。"}]},{type:a,value:c},{type:b,tag:u,props:{id:O},children:[{type:b,tag:g,props:{href:bo,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:O}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"現時点では、 GenJson はシリアライズ機能のみを提供しています。デシリアライズ機能も提供することで、 JSON 文字列から USTRUCT や UENUM に変換することができるようになります。\nというかデシリアライズ機能がないのは使いにくすぎますし、どちらかというと負荷になるのはデシリアライズのほうなので、早急に実装したいです。同様の手法で実装できると考えています。"}]},{type:a,value:c},{type:b,tag:u,props:{id:aF},children:[{type:b,tag:g,props:{href:bp,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:ah}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"GenJson の API は、 C++ から呼び出すことを前提としています。これは、型にあわせたシリアライズ関数の選択が、コンパイル時に静的に行われるため、 Blueprint で指定した構造体をもとにシリアライズ関数を選択することができないためです。\nしかし、この問題は静的に生成された関数を Blueprint から渡される UStruct オブジェクトをキーとして検索することで解決できると考えています。\nこの方法であれば、最上位の USTRUCT に対するシリアライズ関数を発見する検索コストだけが Blueprint からの呼び出し時には追加されますが、その後のシリアライズ処理は C++ からの呼び出しと同様に高速なままでしょう。"}]},{type:a,value:c},{type:b,tag:u,props:{id:P},children:[{type:b,tag:g,props:{href:bq,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:P}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"現時点では、出力された JSON は常に UTF-8 でエンコードされるようになっています。 一般的な用途では問題ありませんが、 UE 内で JSON 文字列を扱う場合には、 UTF-16 に変換して FString で利用できたほうが便利です。\n現状、そのためには変換を挟む必要があり好ましくありません。直接 UTF-16 で JSON 文字列を扱えるようにすることが望ましいです。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"シリアライズ時に、エンコードを指定できるようにしたいです。"}]},{type:a,value:c},{type:b,tag:u,props:{id:Q},children:[{type:b,tag:g,props:{href:br,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:Q}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"散々早いと言ってきましたが、実際にどの程度のパフォーマンスが出るのか、また、どの程度のメモリを消費するのか、といった実測ベースの検証がまだ行われていません。\n(ちゃんとやるつもりだったのですが、アドカレの日までに間に合わなかった……)"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"とはいえ、GenJson はとにかく静的かつ愚直な処理のみを実行時に残すように設計されているため、標準のリフレクション機能を使ったシリアライズよりも高速であることは間違いない……はずです。"}]},{type:a,value:c},{type:b,tag:F,props:{id:an},children:[{type:b,tag:g,props:{href:bs,ariaHidden:l,tabIndex:m},children:[{type:b,tag:e,props:{className:[n,o]},children:[]}]},{type:a,value:an}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"GenJson は、 UHT を拡張して UE の JSON シリアライズ機能を強化するプラグインです。\n標準機能にはない、プロパティ名の柔軟な変更や上書き、高速なシリアライズ、カスタムシリアライズ関数の実装が可能です。\nGenJson は、 USTRUCT や UENUM にメタ指定子を与えるだけで利用可能です。エンジン改造は不要で、プラグインとして導入するだけで利用していただくことができます。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"また、UBT プラグインを使うと、 UHT を拡張してコード生成を行うことができます。 UE におけるコーディングの幅を大きく広げられます。\nUBT プラグインなる機能をエンジンコード上で発見したときは、 「C# の Roslyn "},{type:b,tag:"sup",props:{id:"fnref-1"},children:[{type:b,tag:g,props:{href:"#fn-1",className:["footnote-ref"]},children:[{type:a,value:"1"}]}]},{type:a,value:" みたいなことが UE でできるってこと……？」 と思ってなにか作りたかったので、 GenJson はその一環として生まれました。"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"UBT プラグインの解説記事は、いつか書きますね……。"}]},{type:a,value:c},{type:b,tag:h,props:{className:["footnotes"]},children:[{type:a,value:c},{type:b,tag:"hr",props:{},children:[]},{type:a,value:c},{type:b,tag:"ol",props:{},children:[{type:a,value:c},{type:b,tag:i,props:{id:"fn-1"},children:[{type:a,value:"Roslyn は、 C# のコンパイラとして知られる .NET Compiler Platform のコードベースのことです。 Roslyn は、 C# のコードを解析し、コード生成を行うための API を提供しています。 Roslyn を使うことで、 C# のコードを解析してリファクタリングツールやコード生成ツールを作ることができます。　Roslyn はもとの C# コードの AST をいじることまでできるので、 UHT もそれくらいのことができるといいなあと思っていますが、まだ(たぶん)できません。"},{type:b,tag:g,props:{href:"#fnref-1",className:["footnote-backref"]},children:[{type:a,value:"↩"}]}]},{type:a,value:c}]},{type:a,value:c}]}]},dir:"\u002Farticles\u002Funrealengine",path:bK,extension:".md",createdAt:bL,updatedAt:bL,gitCreatedAt:"2024-12-24T20:46:07.000Z",gitUpdatedAt:"2024-12-25T09:00:19.000Z"},path:bK}],fetch:{"data-v-08b63208:0":{prevTitle:K,nextTitle:K,existPrev:bM,existNext:bM,prevSlug:K,nextSlug:K,seriesPage:K}},mutations:void 0}}("text","element","\n","p","span","code","a","div","li","token","pre","true",-1,"icon","icon-link","code-extra","filename","language-cpp","punctuation",2,"h2","ul","不満なところ",3,"h3","Output Log","language-plaintext","FName"," ","(",")","h1","meta = (Serialize)","プロパティ名のケース変換や上書きが可能","カスタムシリアライズ関数の実装が容易","エンジン改造なし","","シリアライズ関数の自動生成によるハイパフォーマンスなシリアライズ","メタ指定子","メタ指定子はパッケージングで消える","デシリアライズ機能","マルチ文字コードへの対応","メモリ使用量やパフォーマンスの検証","function","operator","=","UENUM にも対応","RapidJson ベース","h4","snake_case","remark-highlight",";","FJsonObject を使った生のオブジェクト操作","UStruct のリフレクションを使った JSON 書き出し","USTRUCT にメタ指定子を与えるだけで JSON シリアライズ機能を利用可能","メタ指定子による JSON シリアライズ機能の制御","UHT とリフレクション","UHT によるコード生成","UBT プラグインによるコード生成の拡張","GenJson によるコード生成","SFINE による関数選択","Blueprint 対応","プロパティ名の柔軟な変更ができない","カスタムシリアライザと併用できない","リフレクションによるオーバーヘッド","#genjson-%E3%81%AE%E6%A9%9F%E8%83%BD%E7%B4%B9%E4%BB%8B","まだ実現できていないこと","まとめと感想","keyword","string","meta ","meta = ()","2024\u002F12\u002F25","fjsonobject-を使った生のオブジェクト操作","ustruct-のリフレクションを使った-json-書き出し","不満なところ-1","ustruct-にメタ指定子を与えるだけで-json-シリアライズ機能を利用可能","uenum-にも対応","rapidjson-ベース","メタ指定子による-json-シリアライズ機能の制御","uht-とリフレクション","uht-によるコード生成","ubt-プラグインによるコード生成の拡張","genjson-によるコード生成","sfine-による関数選択","blueprint-対応","GenJson","nofollow","noopener","noreferrer","_blank","目次","#%E6%A8%99%E6%BA%96%E6%A9%9F%E8%83%BD%E3%81%AE%E4%BD%95%E3%81%8C%E4%B8%8D%E6%BA%80%E3%81%AA%E3%81%AE%E3%81%8B","標準機能の何が不満なのか？","#fjsonobject-%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%9F%E7%94%9F%E3%81%AE%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%93%8D%E4%BD%9C","#%E4%B8%8D%E6%BA%80%E3%81%AA%E3%81%A8%E3%81%93%E3%82%8D","#ustruct-%E3%81%AE%E3%83%AA%E3%83%95%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%9F-json-%E6%9B%B8%E3%81%8D%E5%87%BA%E3%81%97","#%E4%B8%8D%E6%BA%80%E3%81%AA%E3%81%A8%E3%81%93%E3%82%8D-1","#%E3%83%97%E3%83%AD%E3%83%91%E3%83%86%E3%82%A3%E5%90%8D%E3%81%AE%E6%9F%94%E8%BB%9F%E3%81%AA%E5%A4%89%E6%9B%B4%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84","#%E3%83%AA%E3%83%95%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E6%83%85%E5%A0%B1%E3%81%AE-fname-%E3%82%92%E6%96%87%E5%AD%97%E5%88%97%E5%8C%96%E3%81%97%E3%81%A6%E5%88%A9%E7%94%A8%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B","リフレクション情報の FName を文字列化して利用している","#%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%B6%E3%81%A8%E4%BD%B5%E7%94%A8%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84","#%E3%83%AA%E3%83%95%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E3%82%88%E3%82%8B%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%98%E3%83%83%E3%83%89","GenJson の機能紹介","#ustruct-%E3%81%AB%E3%83%A1%E3%82%BF%E6%8C%87%E5%AE%9A%E5%AD%90%E3%82%92%E4%B8%8E%E3%81%88%E3%82%8B%E3%81%A0%E3%81%91%E3%81%A7-json-%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA%E6%A9%9F%E8%83%BD%E3%82%92%E5%88%A9%E7%94%A8%E5%8F%AF%E8%83%BD","#%E3%83%97%E3%83%AD%E3%83%91%E3%83%86%E3%82%A3%E5%90%8D%E3%81%AE%E3%82%B1%E3%83%BC%E3%82%B9%E5%A4%89%E6%8F%9B%E3%82%84%E4%B8%8A%E6%9B%B8%E3%81%8D%E3%81%8C%E5%8F%AF%E8%83%BD","#%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA%E9%96%A2%E6%95%B0%E3%81%AE%E8%87%AA%E5%8B%95%E7%94%9F%E6%88%90%E3%81%AB%E3%82%88%E3%82%8B%E3%83%8F%E3%82%A4%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AA%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA","#%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA%E9%96%A2%E6%95%B0%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%8C%E5%AE%B9%E6%98%93","#uenum-%E3%81%AB%E3%82%82%E5%AF%BE%E5%BF%9C","#%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%B3%E6%94%B9%E9%80%A0%E3%81%AA%E3%81%97","#rapidjson-%E3%83%99%E3%83%BC%E3%82%B9","#genjson-%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%E3%81%A8%E9%96%A2%E9%80%A3-ue-%E6%A9%9F%E8%83%BD%E3%81%AE%E8%A7%A3%E8%AA%AC","GenJson の仕組みと関連 UE 機能の解説","#%E3%83%A1%E3%82%BF%E6%8C%87%E5%AE%9A%E5%AD%90%E3%81%AB%E3%82%88%E3%82%8B-json-%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA%E6%A9%9F%E8%83%BD%E3%81%AE%E5%88%B6%E5%BE%A1","#uht-%E3%81%A8%E3%83%AA%E3%83%95%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3","#%E3%83%A1%E3%82%BF%E6%8C%87%E5%AE%9A%E5%AD%90","#%E3%83%A1%E3%82%BF%E6%8C%87%E5%AE%9A%E5%AD%90%E3%81%AF%E3%83%91%E3%83%83%E3%82%B1%E3%83%BC%E3%82%B8%E3%83%B3%E3%82%B0%E3%81%A7%E6%B6%88%E3%81%88%E3%82%8B","#uht-%E3%81%AB%E3%82%88%E3%82%8B%E3%82%B3%E3%83%BC%E3%83%89%E7%94%9F%E6%88%90","#ubt-%E3%83%97%E3%83%A9%E3%82%B0%E3%82%A4%E3%83%B3%E3%81%AB%E3%82%88%E3%82%8B%E3%82%B3%E3%83%BC%E3%83%89%E7%94%9F%E6%88%90%E3%81%AE%E6%8B%A1%E5%BC%B5","#genjson-%E3%81%AB%E3%82%88%E3%82%8B%E3%82%B3%E3%83%BC%E3%83%89%E7%94%9F%E6%88%90","#sfine-%E3%81%AB%E3%82%88%E3%82%8B%E9%96%A2%E6%95%B0%E9%81%B8%E6%8A%9E","#%E3%81%BE%E3%81%A0%E5%AE%9F%E7%8F%BE%E3%81%A7%E3%81%8D%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8","#%E3%83%87%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA%E6%A9%9F%E8%83%BD","#blueprint-%E5%AF%BE%E5%BF%9C","#%E3%83%9E%E3%83%AB%E3%83%81%E6%96%87%E5%AD%97%E3%82%B3%E3%83%BC%E3%83%89%E3%81%B8%E3%81%AE%E5%AF%BE%E5%BF%9C","#%E3%83%A1%E3%83%A2%E3%83%AA%E4%BD%BF%E7%94%A8%E9%87%8F%E3%82%84%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AE%E6%A4%9C%E8%A8%BC","#%E3%81%BE%E3%81%A8%E3%82%81%E3%81%A8%E6%84%9F%E6%83%B3","生成される JSON","language-json","PascalCase","camelCase","USTRUCT()\nstruct FMyVector\n{\n    GENERATED_BODY()\n\n    UPROPERTY()\n    float X;\n\n    UPROPERTY()\n    float Y;\n\n    UPROPERTY()\n    float Z;\n};","GENJSON_SERIALIZERS","USTRUCT","Serialize","struct","class-name","FUserData","{","\n    ","comment","\u002F\u002F 略","}","\n\n    ","\u002Farticles\u002Funrealengine\u002Ffast-json-serializer-in-unrealengine","2024-12-25T00:00:00.000Z",false)));